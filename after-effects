#!/usr/bin/env bash
# shellcheck disable=SC2059
# vim: filetype=sh

# Author: Prasad Tengse
# Licence: GPLv3
# Github Repository: https://github.com/tprasadtp/ubuntu-post-install
# Requirements - Bash v4 and above
#              - whiptail, wget, iputils-ping, awk, sed, grep
#

readonly AE_EXEC_START=$(date +%s)
readonly SCRIPT=$(basename "$0")

# SCRIPT METADATA
readonly dir=$(cd -P -- "$(dirname -- "$0")" && pwd -P)
readonly REL_NAME="6.3.0"
readonly REL_NUM=630

# Handle Use interrupt
# trap ctrl-c and call ctrl_c()
trap ctrl_c_handler INT

function ctrl_c_handler() {
  printf "${RED}• User Interrupt! CTRL-C${NC}\n"
  exit 4
}

case ${DEBUG} in
  1 | "yes" | "true" | "TRUE")     AE_DEBUG=1;set -o pipefail;;
  2 | "ci" | "CI")                 AE_DEBUG=2;set -eo pipefail;;
  3 | "trace")                     AE_DEBUG=3;set -o pipefail;;
  *)                               AE_DEBUG=0;set -o pipefail;;
esac


function _init_printf_variables()
{
  #Initialize printf variables
  readonly       _phase_repo="(REPO)"
  readonly        _phase_ppa="(PPA)"
  readonly    _phase_install="(INST)"
  readonly      _phase_purge="(PURGE)"
  readonly        _phase_deb="(DPKG)"
  readonly        _phase_apt="(APT)"
  readonly    _phase_apt_key="(KEYS)"
  readonly        _phase_pip="(PIP)"
  readonly       _phase_snap="(SNAP)"

  # Log Premitives
  readonly       _info="[INF]"
  readonly        _dev="[DEV]"
  readonly      _debug="[DBG]"
  readonly    _cleanup="[DEL]"
  readonly    _success="[ OK]"
  readonly       _warn="[WRN]"
  readonly      _error="[ERR]"
  readonly   _variable="[VAR]"
  readonly       _crit="[CRT]"


  #colors for display
  readonly YELLOW=$'\e[38;5;220m'
  readonly GREEN=$'\e[32m'
  readonly RED=$'\e[31m'
  readonly BLUE=$'\e[34m'
  readonly LIGHT_BLUE=$'\e[38;5;159m'
  readonly CYAN=$'\e[38;5;51m'
  readonly NC=$'\e[0m'
  readonly ORANGE=$'\e[38;5;208m'
  readonly TEAL=$'\e[38;5;192m'
  readonly PINK=$'\e[38;5;212m'
  readonly GRAY=$'\e[38;5;246m'
  readonly LOG_GRAY=$'\e[38;5;240m'
  readonly LIGHT_GRAY=$'\e[38;5;242m'
  readonly MAGENTA=$'\e[38;5;219m'
}


function _init_logging()
{
  # Initialize phase 2
  # Only variables necessary for logging & start logging
  # Script related variables are defined in _init_script_variables
  readonly log_file="$dir"/logs/after-effects.log
  {
    mkdir -p "$dir"/logs
  } ||
  {
    printf "${RED}✕ Failed to create logs folder${NC}\n"; exit 2
  }
  # tmp dir
  {
    rm -rf /tmp/ae/*
    mkdir -p /tmp/ae/
  } ||
  {
    printf "${RED}✕ Failed to create tmp folder${NC}\n"; exit 2
  }

  # if file not exists touch it
  if [[ ! -f ${log_file} ]]; then
    if touch "${log_file}"; then
      _log_info "Created log file"
    else
      printf "${RED}✕ Failed to create logfile!${NC}\n"
      exit 2
    fi
  fi

  # check if logs can be written
  if [[ -w $log_file ]]; then
    {
      _log_debug "Initialized logging"
    } ||
    {
      printf "${RED}✕ Failed to write to log file ${log_file} ${NC}\n"; exit 2
    }
  else
    printf "${RED}✕ Log file is not writable!${NC}\n"
    exit 2
  fi
}


# Utility Functions
function _line_fill()
{
  printf "_______________________________________________________\n"
}

function _log_and_exit()
{
  # ARG-1 log msg
  # ARG-2 exit code int
  local msg="$1"
  printf "${RED}✖ $msg ${NC}\n"
  printf "$(date) ${_crit} $msg\n" >> "$log_file"
  exit "$2"
}


function _script_exit_log()
{
    # Script time
    _log_stage "Cleanup and Exit"
    readonly AE_EXEC_END=$(date +%s)
    readonly AE_EXEC_TIME=$(( AE_EXEC_END - AE_EXEC_START ))
    _log_debug "$SCRIPT took $AE_EXEC_TIME seconds to complete."
    exit 0
}

function _log_info()
{
  local msg="$1"
  printf "  • $msg\n"
  printf "$(date) ${_info} $msg\n" >> "$log_file"
}


function _log_debug()
{
  local msg="$1"
  if [[ ${AE_DEBUG} -gt 0 ]]; then
    printf "${GRAY}  • $msg ${NC}\n"
  fi
  printf "$(date) ${_debug} $msg\n" >> "$log_file"
}


function _log_success()
{
  local msg="$1"
  printf "${TEAL}  • $msg ${NC}\n"
  printf "$(date) ${_success} $msg\n" >> "$log_file"
}

function _log_warn()
{
  local msg="$1"
  printf "${YELLOW}  • $msg ${NC}\n"
  printf "$(date) ${_warn} $msg\n" >> "$log_file"
}

function _log_stage()
{
  local msg="$1"
  printf "${MAGENTA}➜ $msg ${NC}\n"
  printf "$(date) ${_info} $msg\n" >> "$log_file"
}

function _log_error()
{
  local msg="$1"
  printf "${RED}  • $msg ${NC}\n"
  printf "$(date) ${_error} $msg\n" >> "$log_file"
}

function _log_dev()
{
  local msg="$1"
  printf "${ORANGE}  • $msg ${NC}\n"
  printf "$(date) ${_dev} $msg\n" >> "$log_file"
}

function _log_notice()
{
  local msg="$1"
  printf "${CYAN}  • $msg${NC}\n"
  printf "$(date) ${_info} $msg\n" >> "$log_file"
}

function _log_var()
{
  local var
  var="$1"
  if [[ $AE_DEBUG -gt 0 ]]; then
    printf "${GRAY}  » %-18s - %-10s${NC}\n" "${var}" "${!var}"
  fi
  printf "$(date) ${_variable} ${var} is set to ${!var}\n" >> "$log_file"
}

function  _log_trace()
{
  # This function adds time stamp to logs without using external utilities
  # Output will be automatically written to $log_file
  # Arguments : 1
  # ARG -1: printf variable for formatting the log
  # Usage command | _add_timestamp_to_logs "$1"
  while IFS= read -r line;
  do
    printf "$(date) [EXT] ${1} %s\n" "$line" &>> "$log_file"
    if [[ $AE_DEBUG -gt 1 ]]; then
      printf "${LOG_GRAY}  » %s %s${NC}\n" "$1" "$line"
    fi
  done

}

function _log_property()
{
  # Args (4)
  # Arg 1 : Property name
  # Arg 2 : Property value
  # Arg 3 : log level can be 0-debug(default)
  #                          1-info
  #                          2-notice
  #                          3-dev
  #                          4-warning
  #                          5-error
  #                          other defaults to debug.
  # Arg 4 : Format string  spacing (default=18)
  local desc value fmt lvl
  local __msg_string
  desc="${1}"
  value="${2}"
  lvl="${3:-0}"
  fmt="%-${4:-18}s"
  __msg_string="$(printf "${fmt} : %s" "${desc}" "${value}")"

  case ${lvl} in
    0)            _log_debug "${__msg_string}";;
    1)            _log_info "${__msg_string}";;
    2)            _log_notice "${__msg_string}";;
    3)            _log_dev "${__msg_string}";;
    4)            _log_warn "${__msg_string}";;
    5)            _log_error "${__msg_string}";;
    *)            _log_debug "${__msg_string}";;
  esac
}

#shellcheck disable=SC2120
function detect_distribution()
{
  # Read /etc/os-release and get
  local OS_RELEASE_FILE

  OS_RELEASE_FILE="${1:-/etc/os-release}"
  if [[ -r "${OS_RELEASE_FILE}" ]]; then
    _log_debug "Found os-release file ${OS_RELEASE_FILE}"
    # Read Version Code Name
    readonly AE_DISTRO_CODENAME="$(awk '/VERSION_CODENAME=/' "${OS_RELEASE_FILE}" | sed 's/VERSION_CODENAME=//' | tr '[:upper:]' '[:lower:]')"

    # Read Human Readable Full Version Name
    readonly AE_DISTRO_PRETTY_NAME="$(awk '/PRETTY_NAME=/' "${OS_RELEASE_FILE}" | sed 's/PRETTY_NAME=//' | tr -d '"')"

    # Read Human Readable Distro Name
    readonly AE_DISTRO_NAME="$(awk '/^NAME=/' "${OS_RELEASE_FILE}" | sed 's/^NAME=//' | tr -d '"')"
  else
    _log_error "Hey, What kind of system is this?"
    _log_and_exit "I cannot determine distro/codename!" "5"
  fi
}


function _init_script_variables()
{
  # Function defines Script variables
  # Necessary variables used by the script are initialized here. This function
  # should be called first before choices are made, always.

  #shellcheck disable=SC2119
  detect_distribution

  # Achtung: Do not set code_name as readonly!!
  code_name="${AE_DISTRO_CODENAME}"
  readonly architecture="$(dpkg --print-architecture)"
  case "${architecture}" in
    amd64)          _log_debug "Architecture is 64 bit.";
                    readonly ARCH="amd64";
                    readonly YQ_BIN_ARCH="amd64";
                    ;;
    i386)           _log_debug "Architecture is 32 bit.";
                    _log_and_exit "i386 is no longer Supported!" "11"
                    ;;
    armhf)          _log_debug "Running on ARM CPU with HW Floating point Processor";
                    readonly ARCH="armhf";
                    readonly YQ_BIN_ARCH="arm";
                    ;;
    arm64)           _log_debug "This is an ARM 64. Please be advised that not all repositories support this arch.";
                    readonly ARCH="arm64";
                    readonly YQ_BIN_ARCH="arm";
                    ;;
    * )             _log_error "Sorry! This architecture is not supported by this script!"
                    _log_and_exit "Unsupported Architecture. $(architecture)" "11"
                    ;;
  esac

  # Get Hostname
  readonly CLIENT_NAME=$(hostname)

  # etc sources list dir
  readonly SOURCES_FILE_DIR=/etc/apt/sources.list.d

  # Ping URL
  readonly PING_URL="http://connectivitycheck.gstatic.com/generate_204"


  #-------------------------- Release codenames --------------------------------------
  readonly codename_latest_release="groovy"
  readonly codename_previous_release="focal"

  # 404 is a placeholder which is  set when there are
  # no suitable releases which can use this feature or
  # the release is unknown or too early in developement.
  readonly codename_upcoming_release="hirsute"

  readonly codename_current_lts="focal"
  readonly codename_previous_lts="bionic"

  readonly codename_latest_debian_release="buster"
  readonly codename_upcoming_debian_release="bullseye"

  #============================ Switches/ booleans & Vars ================================


  # Fix Repo not available for latest release
  bool_fix_repo_not_available_for_latest="false"


  # Allow repo fixes for Upcoming releases of ubuntu and its derivatives.
  bool_fix_repo_not_available_for_upcoming_release="false"

  # Checks for Version
  # Define API node endpoints

  bool_check_version="true"

  readonly api_version_url="https://ae.prasadt.com/get/v3/version"

  # Azure
  readonly AZURE_METADATA_URL="http://169.254.169.254/metadata/instance/compute/location?api-version=2017-08-01&format=text"

  # Achtung!!
  # ========================================================================================= #

  # Purge not required packages
  # Default is false
  # Requires command line option -d to be passed via command line otherwise it will not work.
  # Set this to true if you don't want to pass -d every time
  bool_purge_pkgs="false"

  # Say yes to all (No whiptail dialogs)
  # Default is false
  # Can be set to true and dialog boxes will be skipped if command line option -y is passed.
  # Set this to true if you don't want to pass -y every time
  bool_say_yes_to_all="false"

  # Keep Downloaded DEB packages
  bool_preserve_debs="false"

  #
  # ================================================================================== #
  # Achtung!
  # Do not change any of the variables below this if you don't know what they do.
  # They are essential for correct working of the script.

  # Check Debian Flags
  bool_is_debian="false"

  # Boolean to hold if --fix or --fix-mode-lts or --pre-release was applied
  bool_codename_fix_appied="false"

}



function _init_print_basic_info()
{
  # This function logs and displays the Necessary details which helps in debugging.
  # Should be used after _init_script_variables function.
  _log_property "Hostname"        "${CLIENT_NAME}" 1
  _log_property "OS"              "${AE_DISTRO_PRETTY_NAME}" 1
  _log_property "Distribution"    "${AE_DISTRO_NAME}" 1
  _log_property "Release"         "${AE_DISTRO_CODENAME}" 1
  _log_property "Architecture"    "${ARCH}" 1
  _log_property "Version(Number)" "${REL_NAME}(${REL_NUM})" 1

  _log_property "SOURCES_FILE_DIR" "${SOURCES_FILE_DIR}"

  #disable hist chars  so that I can print "!!"" properly
  histchars=
}


function delete_log_file()
{
  printf "➜ Deleting log file\n"
  if rm "${dir}/logs/after-effects.log"; then
    printf "${GREEN}• Done${NC}\n"
    exit 0
  else
    printf "${RED}• Failed!${NC}\n"
    exit 1;
  fi
}


function _check_dependencies()
{
  #Checks if commands in array are available.
  # Accepts one argument as array.
  local dependencies=("$@")
  local dependency_check_failed_count dep_res dependency
  dependency_check_failed_count=0;
  _log_info "Checking dependencies..."
  for dependency in "${dependencies[@]}"; do
   command -v "$dependency" > /dev/null
   dep_res=$?
   if [ "$dep_res" -eq 1 ]; then
     _log_error "$dependency is not installed!${NC}"
     dependency_check_failed_count=$((dependency_check_failed_count+1))
   fi
  done

  if [ "$dependency_check_failed_count" -gt 0 ]; then
    _log_error "One or more dependencies not installed."
    _log_and_exit "Sorry! $SCRIPT cannot continue!" "1"
  fi
}


function __disp_sig_check_passed()
{
  # Displays message after --verify proves that the GPG signatures match
  printf "${GREEN}✓ Signature verified!${NC}\n"
}


function __disp_sig_check_failed()
{
  # Displays failed GPG signature message
  printf "${RED}✕ Oh No! Signature checks failed.${NC}\n"
  printf "${RED}✕ File is either corrupt or has been modified.${NC}\n"
}


function verify_gpg_signature()
{
  # Verifies the file with its detached GPG signature.
  # Assumes that you already have public key in your keyring.
  # Assumes signature file is present at same location,
  # with same name but with .sig or .gpg or .asc extension.
  local sig_file
  # Checks if file is present
  if [ -f "${SCRIPT}.sig" ]; then
    sig_file="${SCRIPT}.sig"
  elif [ -f "${SCRIPT}.asc" ]; then
    sig_file="${SCRIPT}.asc"
  elif [ -f "${SCRIPT}.gpg" ]; then
    sig_file="${SCRIPT}.gpg"
  else
    printf "${RED}✕ Signature file not found.${NC}\n"
    exit 51;
  fi

  # Check for signature files
  printf "⧗ Verifying GPG signature of file..\n"
  printf "⧗ Signature File : ${sig_file}\n"
  printf "⧗ Data File      : ${SCRIPT}\n"
  # Checks for commands
  if command -v gpg > /dev/null; then
    if gpg --verify "${sig_file}" "${SCRIPT}" >/dev/null  2>&1; then
      __disp_sig_check_passed
    else
      __disp_sig_check_failed
      exit 50;
    fi
  elif command -v gpgv >/dev/null; then
    if gpgv --keyring "$HOME/.gnupg/pubring.kbx" "${sig_file}" "${SCRIPT}" > /dev/null  2>&1; then
      __disp_sig_check_passed
    else
      __disp_sig_check_failed
      exit 50;
    fi
  else
    printf "${RED}✕ Cannot perform verification. gpgv or gpg is not installed.${NC}\n"
    printf "${RED}✕ This action requires gnugpg/gnupg2 or gpgv package.${NC}\n"
    exit 1;
  fi

}


function _eol_message()
{
  # Display EOL Message and upgrade instruction URLs.
  # Arguments: 1
  # ARG 1: EOL Date

  _log_error "This version of ${AE_DISTRO_NAME} is no longer supported."
  _log_and_exit "${AE_DISTRO_PRETTY_NAME} will reach EOL pretty soon ($1)." "12"
}


function _fix_ubuntu_derivatives()
{
  # Some Ubuntu based distributions use their own codename (Linux mint, Elementary)
  # Some repositories require that ubuntu codename is used.
  # This function fixes that for
  # Linux Mint 20.x : Ubuntu 20.04 Xenial,
  # Linux Mint 19.x : Ubuntu 18.04 Xenial,
  # Elementary OS Juno,Hera: Ubuntu 18.04 Xenial
  # Pop!_OS uses Ubuntu codenames (No need to apply fix)
  # KDE Neon, Bodhi, Peppermint use Ubuntu codenames
  # If the release is not known this function exits the script for safety.

  _log_stage "Checking for Ubuntu derivates/Debian"
  _log_var "code_name"
  case ${code_name} in
      # Ubuntu 18.04 and its derivatives
      bionic )                              readonly bool_config_partner_repo="true";
                                            readonly enable_ppa="true";
                                            readonly distro_name="ubuntu";
                                            _log_info "This is a LTS release of Ubuntu (18.04)"
                                            _log_success "Keeping the codename as $code_name."
                                            ;;
      tara | tessa | tina | tricia )        _log_info "This is Linux-Mint 19.X."
                                            _log_info "Setting additional repositories to follow Ubuntu 18.04."
                                            code_name="bionic";
                                            readonly distro_name="ubuntu";
                                            readonly enable_ppa="true";
                                            _log_success "Changed codename to $code_name"
                                            ;;
      juno | hera)                          _log_info "This release of Elementary OS is based on Ubuntu 18.04 Bionic."
                                            _log_info "External repositories will use Ubuntu 18.04."
                                            code_name="bionic";
                                            readonly distro_name="ubuntu";
                                            readonly enable_ppa="true";
                                            _log_success "Changed codename to $code_name"
                                            ;;
      # Ubuntu 20.04 and its derivatives
      focal )                               readonly bool_config_partner_repo="true";
                                            readonly python2_disabled="true";
                                            readonly enable_ppa="true";
                                            readonly distro_name="ubuntu";
                                            _log_info "This is latest LTS release of Ubuntu"
                                            _log_success "Keeping the codename as $code_name."
                                            ;;
      ulyana | ulyssa )                     _log_info "Release is Linux mint 20.X."
                                            _log_info "Setting additional repositories to follow Ubuntu 20.04."
                                            code_name="focal";
                                            readonly python2_disabled="true";
                                            readonly distro_name="ubuntu";
                                            readonly enable_ppa="true";
                                            _log_success "Changed codename to $code_name"
                                            ;;
      # Current Ubuntu release (Can be non LTS)
      groovy)                               readonly bool_config_partner_repo="true";
                                            readonly enable_ppa="true";
                                            readonly python2_disabled="true";
                                            readonly distro_name="ubuntu";
                                            _log_notice "Release is Ubuntu 20.10 Groovy Gorilla"
                                            ;;
      # Upcoming Ubuntu release
      hirsute)                              readonly bool_config_partner_repo="true";
                                            readonly enable_ppa="true";
                                            readonly python2_disabled="true";
                                            readonly distro_name="ubuntu";
                                            _log_warn "Release is Ubuntu 21.04 Hirsute Hippo (Unstable!!)"
                                            ;;
      # Current Debian releases
      stretch | buster )                    bool_is_debian="true";
                                            readonly distro_name="debian";
                                            readonly enable_ppa="false";
                                            _log_notice "This is Debian. PPAs are disabled."
                                            ;;
      # Upcoming Debian release
      bullseye )                            bool_is_debian="true";
                                            readonly enable_ppa="false";
                                            readonly distro_name="debian";
                                            _log_dev "You are running Debian Testing!"
                                            _log_warn "This is pre release version of Debian. Use with caution!"
                                            _log_notice "PPAs are disabled."
                                            ;;
      # Unsupported releases
      jessie)                               _eol_message "June  2020";;
      xenial)                               _eol_message "April 2021";;
      sarah | serena | sonya | sylvia)      _eol_message "April 2021";;
      tara | tessa | tina | tricia)         _eol_message "April 2021";;
      loki)                                 _eol_message "April 2021";;
      *)                                    _log_error "Unknown or unsupported release($code_name) !!"
                                            _script_exit_log;
                                            exit 16;
                                            ;;
  esac

  _log_success "Applied release specific settings and fixes."
  _log_var "code_name"

}


function _test_internet_connection ()
{
  # Function to check internet connection
  _log_info "Checking connectivity"
  if wget --tries=2 --timeout=10 "$PING_URL" -O /tmp/ae/testinternet &>/dev/null 2>&1; then
    rm -f /tmp/ae/testinternet
    _log_success "Connected!"
  else
    _log_error "You are not connected to the Internet!. "
    _log_error "Please check your Internet connection and try again."
    rm -f /tmp/ae/testinternet || _log_debug "Failed to remove temp network connectivity resp file"
    _log_and_exit "No internet connection!" "14"
  fi
}


function _test_conflicting_apps ()
{
  # Function checks if any apps like syanptic aptitude are running.
  local lock
  for lock in synaptic update-manager software-center apt-get dpkg aptitude
  do
    # shellcheck disable=SC2009
    if ps -U root -u root u | grep $lock | grep -v grep > /dev/null; then
      _log_and_exit "Installation won't work. Please close $lock first then try again." "15"
    else
      _log_property "$lock" "not running"
     fi
   done
   _log_success "No conflicts detected"
}




function parse_yaml() {
  local yaml_file="${1}"
  local prefix="${2}"
  local s
  local w
  local fs

  s='[[:space:]]*'
  w='[a-zA-Z0-9_.-]*'
  fs="$(echo @|tr @ '\034')"

    (
        #shellcheck disable=SC1003
        sed -e '/- [^\"]'"[^\']"'.*: /s|\([ ]*\)- \([[:space:]]*\)|\1-\'$'\n''  \1\2|g' |

        sed -ne '/^--/s|--||g; s|\"|\\\"|g; s/[[:space:]]*$//g;' \
            -e "/#.*[\"\']/!s| #.*||g; /^#/s|#.*||g;" \
            -e "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
            -e "s|^\($s\)\($w\)${s}[:-]$s\(.*\)$s\$|\1$fs\2$fs\3|p" |

      awk -F"$fs" '{
          indent = length($1)/2;
          if (length($2) == 0) { conj[indent]="+";} else {conj[indent]="";}
          vname[indent] = $2;
          for (i in vname) {if (i > indent) {delete vname[i]}}
              if (length($3) > 0) {
                  vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("__")}
                  printf("%s%s%s%s=(\"%s\")\n", "'"$prefix"'",vn, $2, conj[indent-1],$3);
              }
          }' |

        sed -e 's/_=/+=/g' |

        awk 'BEGIN {
                FS="=";
                OFS="="
            }
            /(-|\.).*=/ {
                gsub("-|\\.", "_", $1)
            }
            { print }'
) < "$yaml_file"
}


function _get_remote_file()
{
  # Function to get remote file/response
  # exits script if it fails.
  # Accepts 2 arguments.
  # ARG 1: File name; Name of the local file the response or file should be saved as.
  # ARG 2: URL to the  file

  local file_name="${1}"
  local exit_status
  local file_url="${2}"
  _log_property "URL is set to" "${file_url}"

  if [ "$#" -eq 2 ]; then
    # Remote files
    wget -q "${file_url}" -O "$file_name" >> $"$log_file"
    exit_status="$?"

    _log_property "Exit code (wget)" "$exit_status"
    if [[ $exit_status -ne 0 ]]; then
      _log_error "Something went wrong while retrieving ${file_name}."
      _log_and_exit "Error Getting file." "28"
    fi
  else
    _log_and_exit "Invalid number of arguments <_get_remote_file> Requires 2, got $#." "19"
  fi

}


function _version_checks ()
{
  # Checks if its running latest version.
  # Also suggest updating to latest version if current version is not latest,
  # Allows to deprecate old version as it can be suggested.
  # Check if Version Checks is enabled. (Default is enabled)
  if [ "$bool_check_version" == "true" ]; then
      _log_stage "Checking for updates"
      _log_property "Version URL" "${api_version_url}"
      if [ "$bool_custom_v_file" != "true" ]; then
        rm -f "/tmp/ae/api-version.yml" || _log_debug "Deleting old version YAML failed."
        readonly version_yaml_file="/tmp/ae/api-version.yml"
        # Get response/file
        _get_remote_file "$version_yaml_file" "$api_version_url"
      else
        _log_dev "Using custom version info file $custom_v_file"
        readonly version_yaml_file="$custom_v_file"
      fi

      # Parse YAML to variables
      eval "$(parse_yaml "$version_yaml_file")"
      # Assign them to local variables as sometimes bash if does not handle array elements very well.
      local api_rel_num="${version__number[0]}"

      # Assign Statistics reporting flag and endpoint to Global variables.
      # Debug Info
      _log_property "Version Number (API)" "${api_rel_num}"
      _log_property "Version Name(API)" "${version__name[0]}"

      # If release number is higher than one in the script throw error & ask to update.
      if [[ $api_rel_num -gt $REL_NUM ]]; then
        _log_error "A newer version is available."
        _log_error "Please download latest version and try again."
        _log_notice "Latest available version is ${version__name[0]}-${api_rel_num}."
        _log_and_exit "You can disable version checks by passing --skip-version-check" "24"
      elif [[ $api_rel_num -eq $REL_NUM ]]; then
        _log_success "Running the latest version!"
      elif [[ $api_rel_num -lt $REL_NUM ]]; then
        _log_dev "You are running version ${REL_NAME}(${REL_NUM})."
        _log_dev "Latest stable version is ${version__name[0]}(${api_rel_num})."
      fi

  # If version checks have been disabled
  else
    _log_warn "Version checks have been disabled."
  fi
  #sleep 5

}


function _check_bool()
{
  # Function to check if config has valid values for bool.
  # Accepted values are true and false
  # If invalid, defaults to false.
  # Accepts global var and bool to check as arguments
  local g_var param_bool default_val
  if [[ $# -eq 2 ]]; then
    default_val="false"
  else
    _log_and_exit "Internal error! bool validator takes only two arguments!" "19"
  fi

  g_var="${1}"
  param_bool="${2}"
  case "${param_bool}" in
    true | True | TRUE | Yes | yes | YES | 1 )  declare -g ${g_var}="true"
                                                _log_var "$g_var"
                                                ;;
    false | False | FALSE | No | no | NO | 0 )  declare -g ${g_var}="false"
                                                _log_var "$g_var"
                                                ;;
    *)                                          declare -g ${g_var}="${default_val}"
                                                _log_var "$g_var"
                                                ;;
  esac
}


function _set_yaml_config()
{
  local config_yaml_file
  # Get and parse the file
  _log_stage "Processing configuration..."
  if [ "$bool_local_config" != "true" ]; then
    _log_property "Config URL" "${url_remote_yaml}" 3
    if [[ -e "/tmp/ae/api-config.yml" ]]; then
      rm -f "/tmp/ae/api-config.yml" || _log_and_exit "Deleting old version YAML failed." "38"
    fi
    readonly config_yaml_file="/tmp/ae/api-config.yml"
    # Get response/file
    _get_remote_file "$config_yaml_file" "$url_remote_yaml"
  else
    _log_property "Config file" "$local_config_file" 2
    readonly config_yaml_file="$local_config_file"
  fi

  # Parse YAML to variables
  _log_property "Parsing config" "$config_yaml_file" 2
  eval "$(parse_yaml "$config_yaml_file")"


  # Repo flags
  #################################################################################
  _check_bool "add_docker_repo" "${config__add_repo__docker[0]}"
  #add_docker_repo="${config__add_repo__docker[0]}"

  _check_bool "add_winehq_repo" "${config__add_repo__winehq[0]}"
  #add_winehq_repo="${config__add_repo__winehq[0]}"

  _check_bool "add_mendeley_repo" "${config__add_repo__mendeley[0]}"
  #add_mendeley_repo="${config__add_repo__mendeley[0]}"

  _check_bool "add_gcp_repo" "${config__add_repo__googlecloud[0]}"
  #add_gcp_repo="${config__add_repo__googlecloud[0]}"
  _check_bool "add_gcsfuse_repo" "${config__add_repo__gcsfuse[0]}"

  _check_bool "add_spotify_repo" "${config__add_repo__spotify[0]}"
  #add_spotify_repo="${config__add_repo__spotify[0]}"

  _check_bool "add_skype_repo" "${config__add_repo__skype[0]}"
  #add_skype_repo="${config__add_repo__skype[0]}"

  _check_bool "add_vscode_repo" "${config__add_repo__vscode[0]}"
  #add_vscode_repo="${config__add_repo__vscode[0]}"

  _check_bool "add_insync_repo" "${config__add_repo__insync[0]}"
  #add_insync_repo="${config__add_repo__insync[0]}"

  _check_bool "add_signal_repo" "${config__add_repo__signal[0]}"
  #add_signal_repo="${config__add_repo__signal[0]}"

  _check_bool "add_google_repo" "${config__add_repo__google[0]}"
  #add_google_repo="${config__add_repo__google[0]}"

  # ROS
  _check_bool "add_ros_repo" "${config__add_repo__ros[0]}"

  # DUO
  _check_bool "add_duo_repo" "${config__add_repo__duo[0]}"

  _check_bool "add_gh_repo" "${config__add_repo__github[0]}"

  _check_bool "add_hashicorp_repo" "${config__add_repo__hashicorp[0]}"

  _check_bool "add_gvisor_repo" "${config__add_repo__gvisor[0]}"

  # Other Script Flags
  #################################################################################

  # Purge Packages
  if [[ $bool_purge_pkgs == "true" ]]; then
    _log_debug "Ignoring config.flags.purge_enabled because of cli flag"
  else
    _check_bool "bool_purge_pkgs" "${config__flags__purge_enabled[0]}"
  fi
  #bool_purge_pkgs="${config__flags__purge_enabled[0]}"

  # Keep Debs
  if [[ $bool_preserve_debs == "true" ]]; then
    _log_debug "Ignoring config.flags.preserve_debs because of cli flag"
  else
    _check_bool "bool_preserve_debs" "${config__flags__preserve_debs[0]}"
  fi
  #bool_preserve_debs="${config__flags__preserve_debs[0]}"

  # Uni-Mirror
  _check_bool "bool_use_uf_mirror" "${config__flags__uni_freiburg_mirror[0]}"

  # Tasks Flags
  ##################################################################################

  #ae_task_update="${config__tasks__update[0]}"
  _check_bool "ae_task_update" "${config__tasks__update[0]}"

  #ae_task_upgrade="${config__tasks__upgrade[0]}"
  _check_bool "ae_task_upgrade" "${config__tasks__upgrade[0]}"

  #ae_task_repo="${config__tasks__repo[0]}"
  _check_bool "ae_task_repo" "${config__tasks__repo[0]}"

  #ae_task_ppa="${config__tasks__ppa[0]}"
  _check_bool "ae_task_ppa" "${config__tasks__ppa[0]}"

  #ae_task_apt="${config__tasks__apt[0]}"
  _check_bool "ae_task_apt" "${config__tasks__apt[0]}"

  #ae_task_debs="${config__tasks__debs[0]}"
  _check_bool "ae_task_debs" "${config__tasks__debs[0]}"

  #ae_task_purge="${config__tasks__purge[0]}"
  _check_bool "ae_task_purge" "${config__tasks__purge[0]}"

  #ae_task_pip2="${config__tasks__pip2[0]}"
  _check_bool "ae_task_pip2" "${config__tasks__pip2[0]}"

  #ae_task_pip3="${config__tasks__pip3[0]}"
  _check_bool "ae_task_pip3" "${config__tasks__pip3[0]}"

  # Binaries Install
  _check_bool "ae_task_bin" "${config__tasks__binaries[0]}"

  # snap Packages
  _check_bool "ae_task_snaps" "${config__tasks__snaps[0]}"


  #################################################################################
  #                              Parse Arrays
  #################################################################################
  # Config file YAML has arrays of apt packages.
  # We need to parse apt packages, ppa's, deb packages, python modules listed in yaml
  # to bash arrays.

  #--------------------------------------------------------------------------------
  #                               APT Lists
  #--------------------------------------------------------------------------------
  # There are Seven lists under key config.install.apt.[mentioned from 1-7]
  # 1. administration : Contains Administrative packages
  # 2. security       : contains Security related tools and packages
  # 3. productivity   : Office tools, writing tools, LateX, document tools and other
  #                     productivity tools, Email clients, browsers, IM clients etc.
  #                   : Example : LateX, TeXStudio, Libre office, pandoc empathy, Thunderbird
  # 4. Multimedia     : Multimedia tools like media players, audio converters and playes etc.
  # 5. development    : IDEs [Spyder, Jetbeans etc], languages [go, python, ruby, rust, java etc],
  #                   : Containers [docker lxc rkt etc], Python libraries, compilers [gcc, clang]
  #                   : SDKs [AWS SDK, Coogle Cloud SDK, open-jdk, Tensor Flow], headers
  #                   : and libraries[ocl-icd-dev],
  #                   : Anything related to development and *-dev or *-devl packages.
  # 6. other          : Everything which doesnot fit in the above categories.
  #                   : Themes, Tools, Utilities like htop etc.
  # 7. External       : Any packages which are provided by ppas, or repositories not present in
  #                   : base *buntu distribution. There's a possibility that the repository might not
  #                   : be added or may be unavailable or offline. So Keeping the list seperate from
  #                   : others packages minimizes errors if there are any.
  # This classification is only for ease of use and need not be strictly followed. You can put
  # vlc package in 'security', it will still install fine. This classification helps
  # while writing configs and editing them. Its advised to follow it if your configs
  # tend to get to couple of hundreds of lines. Also YAML file should be a valid YAML.

  #--------------------------------------------------------------------------------
  #                             Special list - Purge list
  #--------------------------------------------------------------------------------
  # There is a special package list under key, config.purge or purge.list, which contains
  # list of apt packages to be purged from the system if present.
  # Lets get em, shall we?

  # Copy package array
  declare -gar parsed_purge_packages=("${config__purge_[@]}")
  declare -gar parsed_administration_packages=("${config__install__apt__administration_[@]}")
  declare -gar parsed_secutity_packages=("${config__install__apt__security_[@]}")
  declare -gar parsed_productivity_packages=("${config__install__apt__productivity_[@]}")
  declare -gar parsed_multimedia_packages=("${config__install__apt__multimedia_[@]}")
  declare -gar parsed_development_packages=("${config__install__apt__development_[@]}")
  declare -gar parsed_other_packages=("${config__install__apt__other_[@]}")
  declare -gar parsed_external_packages=("${config__install__apt__external_[@]}")

  #--------------------------------------------------------------------------------
  #                             PPA Lists
  #--------------------------------------------------------------------------------
  # Config file contains list of PPAs to be added under key
  # config.ppa
  declare -gar parsed_ppa_list=("${config__ppa_[@]}")

  #--------------------------------------------------------------------------------
  #                             Debian packages
  #--------------------------------------------------------------------------------
  # Config file contains list of DEB packages to be downloaded & installed under key
  # config.install.debian_packages
  # The configuration is not simple URL its csv. <URL to Deb file>,<Name of the Package>
  # This is for compatiblity reasons
  declare -gar parsed_deb_files_list=("${config__install__debian_packages_[@]}")

  #--------------------------------------------------------------------------------
  #                             Python Modules
  #--------------------------------------------------------------------------------
  # There are two keys under config.install.python(2/3) which contain Python 2 and Python 3
  # Modules respectively. Please donot mix python 2 Modules with Python 3.

  declare -gar parsed_pip2_packages=("${config__install__python2_[@]}")
  declare -gar parsed_pip3_packages=("${config__install__python3_[@]}")
  declare -gar parsed_bin_packages=("${config__install__binaries_[@]}")

  #--------------------------------------------------------------------------------
  #                             Snap Packages
  #--------------------------------------------------------------------------------
  declare -gar parsed_snap_normal_packages=("${config__install__snaps__normal_[@]}")
  declare -gar parsed_snap_classic_packages=("${config__install__snaps__classic_[@]}")
  declare -gar parsed_snap_edge_packages=("${config__install__snaps__edge_[@]}")

}


function _clean_apt_cache()
{
  # Function to clean apt package cache. Takes care of -k flag in all the installs.
  # Honor -k flag
  # Delete DEBs
  if [ "$bool_preserve_debs" != "true" ];then
    _log_debug "Removing cached APT packages"
    apt-get -q -o=Dpkg::Use-Pty=0 clean | _log_trace "${_phase_apt}"
  else
    _log_notice "Keeping cached packages because -k flag is set."
  fi

}


function _install_dependencies()
{
  # Install packages mentioned in the arguments.
  # If installation fails exit the script.
  # ARG 1: Packages in quote separated by space.
  local packages=("$@")
  _log_debug "Installing Packages ${packages[*]}"
  # Check if array is empty
  if [[ ${#packages[@]} -eq 0 ]]; then
    _log_warn "Package array is empty!" "19"
  else
    apt-get -q -o=Dpkg::Use-Pty=0 -y --no-install-recommends install "${packages[@]}" |& _log_trace "${_phase_apt}"  \
    || _log_and_exit "Failed to install dependencies. Script cannot continue!!" "21"

    exit_status=$?
    if [ $exit_status -eq 0 ]; then
       _log_success "Installed"
    else
      _log_error "Something went wrong while installing dependencies."
      _log_and_exit "Please see the log file for more details." "21"
    fi
  _clean_apt_cache
  fi
}


function _install_pre_requisites()
{
  # This function installs required packages for adding apt repositories
  # These should be present in your base Ubuntu install. If not present then, this function
  # will install them.
  # Following are the packages installed by this function:
  # linux-image-extra-<>, apt-transport-https, ca-certificates,
  # curl, software-properties-common
  local pre_requisite_packages=(apt-transport-https ca-certificates curl gnupg2)
  _log_info "Installing necessary dependencies..."
  _install_dependencies "${pre_requisite_packages[@]}"

}


function _fix_repo_not_available()
{
  # If repository is not available for latest Ubuntu release, this uses last stable release
  # (may not be LTS) for adding repository

  _log_debug "Check and apply codename fixes"
  if [ "$bool_fix_repo_not_available_for_latest" == "true" ]; then
    # Check LTS fallback flag is being used
    # if running on current LTS, and fix mode is LTS fallback to last LTS.
    if [[ $bool_fix_repo_lts == "true" ]] && [[ $code_name == "${codename_current_lts}" ]] ; then
      _log_warn "Using Previous LTS release ::${codename_previous_lts}::"
      code_name="$codename_previous_lts"
      # note applied fix
      bool_codename_fix_appied="true"

    elif [[ $bool_fix_repo_lts != "true" ]] && [[ $code_name == "${codename_latest_release}" ]] ; then
      _log_warn "Using previous release ${codename_previous_release} as fallback"

      # fallback is non LTS so it might disapper/become unsupported! warn
      if [[ $codename_previous_release != "$codename_current_lts"  ]]; then
        _log_warn "Fallback Ubuntu (${codename_latest_release}) is a non LTS release!"
      fi
      code_name="$codename_previous_release"
      bool_codename_fix_appied="true"

    else
      _log_warn "Not applicable."
      bool_codename_fix_appied="false"
    fi # lts
  else
    bool_codename_fix_appied="false"
    _log_debug "Feature --fix/--fix-mode-lts is not available or disabled."
  fi # fix
}

function _warn_about_fix_codename()
{
  _log_warn "Repositories from older Ubuntu release are being used."
  _log_warn "You need to modify this in Software and Updates,\n"
  _log_warn "when they become available for ${codename_upcoming_release}${NC}\n"
}

function _fix_repo_not_available_upcoming_release()
{
  # If repository is not available for upcoming  release, this uses last stable release
  # Aka if the pre-release release is 18.04 it might use 17.10 if used with --fix, it will use 18.04 repos.
  # With Debian If release is 11, when used with this flag we will use Debian 10 repos.
  # --fix is not valid in case of Debian, only --pre-release applies.

  _log_debug "Check and apply codename fixes (--pre-release)"
  # check for fix-pre-release flag
  if [ "$bool_fix_repo_not_available_for_upcoming_release" == "true" ]; then

    if [[ $bool_fix_repo_lts == "true" ]] && [[ $code_name == "${codename_upcoming_release}" ]]; then
      _log_warn "Using lastest Ubuntu LTS (${codename_current_lts}) as fallback!"
      code_name="${codename_current_lts}"
      bool_codename_fix_appied="true"

    elif [[ $bool_fix_repo_lts != "true" ]] && [[ $code_name == "${codename_upcoming_release}" ]]; then
      _log_warn "Using lastest Ubuntu (${codename_latest_release}) as fallback!"
      code_name="${codename_latest_release}"
      bool_codename_fix_appied="true"

    elif [[ $code_name == "$codename_upcoming_debian_release" ]]; then
      _log_dev "Pre-Release-Fix-Codename is experimental on Debian"
      _log_warn "Using lastest Debian Stable (${codename_latest_debian_release}) as fallback!"

      code_name="${codename_latest_debian_release}"
      bool_codename_fix_appied="true"

    else
      _log_warn "Not applicable."
      bool_codename_fix_appied="false"
    fi # check codenames

  else
    _log_debug "Feature fix_repo_not_available_upcoming_release is disabled."
    bool_codename_fix_appied="false"

  fi
}


function add_ppas()
{
  # Function to add ppa by reading ppas from ppa.list of from YAML key config.ppa
  # List/Config file should contain ppas in following format
  # ppa:ppa:<author>/<ppa> for example, ppa:mozillateam/firefox-nex for adding firefox next/Beta PPA
  _log_stage "Adding PPAs"
  local index;
  local _ppa_dependencies=(apt-transport-https ca-certificates curl gnupg2 software-properties-common)
  # Function Reads the file ${dir}/data/ppa.index and adds the ppa one by one.
  # Install dependencies required
  if [ "$bool_is_debian" != "true" ]; then
    _install_pre_requisites;
    _install_dependencies "${_ppa_dependencies[@]}"

      for index in "${parsed_ppa_list[@]}"; do
            _log_info "Setting up PPA - $index"
            # Check for empty lines
            if [ "$index" == "" ]; then
              _log_debug "Found and empty entry, moving on to next..."
              continue
            fi
            if add-apt-repository -y "$index" |& _log_trace "${_phase_ppa}" ; then
              _log_success "Success!"
            else
              _log_error "Some error occured while adding $index.\n"
            fi
        done
  else
    _log_error "This is Debian. PPAs are not available."
  fi

}


function add_repositories()
{
  # This function adds repositories for several apps like
  # Google Chrome, Spotify, Google Cloud SDK, GCSFUSE(Part of google cloud),
  # Skype, Docker, Skype, Microsoft Visual Studio Code, Google Earth, Insync client, Wine-HQ etc
  # WARNING: Some repositories might not support latest version of Ubuntu.

  _log_stage "Setting up repositories"


  #local CLOUD_SDK_REPO
  local GCSFUSE_REPO
  local exit_status
  # install dependencies required
  _install_pre_requisites;
  # if repository is not available for latest ubuntu release, use previous release
  # Be careful, things might not be compatible
  _fix_repo_not_available_upcoming_release;
  _fix_repo_not_available;


  if [ "$ARCH" != "amd64" ]; then
    _log_error "Google Chrome, Spotify, VSCode, Mendeley, Signal and Duo for Unix are only supported on 64 Bit"
  else
    _log_debug "Arch is 64 Bit Enable adding 64 bit repos."
    # 64 bit Only REPOS
    # Add Google Chrome and Google Earth
    if [ "$add_google_repo" == "true" ]; then
      _log_info "Google Chrome & Google Earth"
      _log_debug "Adding Google package signing Key"
      wget -q  https://dl.google.com/linux/linux_signing_key.pub -O /tmp/ae/google_signing_key.pub >> $"$log_file"
      _log_debug "Adding Google key to trusted keys list"
      apt-key add /tmp/ae/google_signing_key.pub |& _log_trace "${_phase_apt_key}" \
      || _log_error "Adding trusted keys for Google failed."

      _log_info "Google Chrome"
      echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main #Google-Chrome" > ${SOURCES_FILE_DIR}/google-chrome.list \
      || _log_error "Adding Google Chrome Repository failed"

      _log_info "Google Earth"

      echo "deb [arch=amd64] http://dl.google.com/linux/earth/deb/ stable main #Google-Earth" > ${SOURCES_FILE_DIR}/google-earth.list \
      || _log_error "Adding Google Chrome repository failed"
    else
      _log_debug "Skipped Google chrome, Google Earth"
    fi


    # Spotify client
    if [ "$add_spotify_repo" == "true" ]; then
      _log_info "Spotify"
      _log_debug "Adding Spotify keys"
      apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 8FD3D9A8D3800305A9FFF259D1742AD60D811D58 2>&1 \
      |_log_trace "${_phase_apt_key}"  \
      || _log_error "Adding Spotify repository failed"

      echo "deb [arch=$ARCH] http://repository.spotify.com stable non-free #Spotify" > ${SOURCES_FILE_DIR}/spotify.list \
      || _log_error "Adding Spotify Repository Failed"
    else
      _log_debug "Skipped Spotify."
    fi


    # Google Cloud SDK and GCS-FUSE
    if [ "$add_gcp_repo" == "true" ] || [ "$add_gcsfuse_repo" == "true" ]; then
      __add_repo_keys --name "Google Cloud Platform Repository" \
        --format "gpg" \
        --file-prefix "google-cloud" \
        --key-url https://packages.cloud.google.com/apt/doc/apt-key.gpg
    else
      _log_debug "GCSFUSE or Google cloud SDK install enabled. Not adding Google cloud APT keys"
    fi

    if [ "$add_gcp_repo" == "true" ]; then
      #CLOUD_SDK_REPO="cloud-sdk-${code_name}"
      _log_info "Google-Cloud-SDK"
      echo "deb [arch=$ARCH signed-by=/usr/share/keyrings/google-cloud.gpg] http://packages.cloud.google.com/apt cloud-sdk main #Google-Cloud-SDK" > ${SOURCES_FILE_DIR}/google-cloud-sdk.list  \
      || _log_error "Adding Google Cloud SDK Repository failed"
    else
      _log_debug "Skipped Google Cloud SDK."
    fi

    if [ "$add_gcsfuse_repo" == "true" ]; then
      _log_info "GCSFUSE"
      if [[ $ARCH == "amd64" ]]; then
        echo "deb [arch=$ARCH signed-by=/usr/share/keyrings/google-cloud.gpg] http://packages.cloud.google.com/apt gcsfuse-${code_name} main #GCSFUSE" > ${SOURCES_FILE_DIR}/gcsfuse.list  \
        || _log_error "Adding GCSFUSE Repository failed"
      else
        _log_error "This architecture($ARCH) is not supported for GCSFUSE."
      fi
    else
      _log_debug "Skipped GCSFUSE"
    fi

    # Skype
    if [ "$add_skype_repo" == "true" ]; then
      _log_info "Skype for Linux"
      _log_debug "Getting Skype repository key"
      wget -q https://repo.skype.com/data/SKYPE-GPG-KEY -O /tmp/ae/skype-linux-key.gpg >> "$log_file"
      _log_debug "Adding Skype keys to trusted list"
      apt-key add /tmp/ae/skype-linux-key.gpg |& _log_trace "${_phase_apt_key}" \
      || _log_error "Adding Skype for linux key failed"
      echo "deb [arch=$ARCH] https://repo.skype.com/deb stable main #Skype" > $SOURCES_FILE_DIR/skype-stable.list \
      || _log_error "Adding Skype for linux repository failed"
    else
      _log_debug "Skipped Skype for Linux."
    fi

    # Visual Studio Code
    if [ "$add_vscode_repo" == "true" ]; then
      _log_info "Visual Studio Code"
      _log_debug "Getting GPG keys for repository"
      wget -q https://packages.microsoft.com/keys/microsoft.asc -O /tmp/ae/microsoft.asc
      _log_debug "Adding Key to trusted GPG keys directory"
      apt-key add /tmp/ae/microsoft.asc |& _log_trace "${_phase_apt_key}" || _log_error "Adding Visual Studio Code key failed"
      echo "deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main #Visual-Studio-Code" > ${SOURCES_FILE_DIR}/vscode.list
    else
      _log_debug "Skipped Visual Studio Code."
    fi

    # Signal App
    if [ "$add_signal_repo" == "true" ]; then
      _log_info "Signal Desktop"
      wget -q https://updates.signal.org/desktop/apt/keys.asc -O /tmp/ae/signal.asc >> "$log_file"
      apt-key add /tmp/ae/signal.asc  |& _log_trace "${_phase_apt_key}" \
      || _log_error "Adding Signal Key Failed"
      echo "deb [arch=amd64] https://updates.signal.org/desktop/apt xenial main #Signal-for-Desktop"  > ${SOURCES_FILE_DIR}/signal-xenial.list
    else
      _log_debug "Skipped Signal Desktop."
    fi

    # Mendeley Desktop App
    if [ "$add_mendeley_repo" == "true" ]; then
      _log_info "Mendeley Desktop"
      apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 6F036044 |& _log_trace "${_phase_apt_key}" \
      || _log_error "Adding Mendeley Desktop Key Failed"
      echo "deb [arch=$ARCH] https://desktop-download.mendeley.com/download/apt stable main #Mendeley-Desktop"  > ${SOURCES_FILE_DIR}/mendeleydesktop.list
    else
      _log_debug "Skipped Mendeley Desktop"
    fi

    # Duo Unix
    if [ "$add_duo_repo" == "true" ]; then
      _log_info "Duo Security for Unix"
      case "$code_name" in
        focal)      duo_repo_url="https://pkg.duosecurity.com/Ubuntu focal main";
                    duo_supported="true";
                    ;;
        bionic)     duo_repo_url="http://pkg.duosecurity.com/Ubuntu bionic main";
                    duo_supported="true";
                    ;;
        xenial)     duo_repo_url="http://pkg.duosecurity.com/Ubuntu xenial main"
                    duo_supported="true";
                    ;;
        stretch)    duo_repo_url="http://pkg.duosecurity.com/Debian stretch main";
                    duo_supported="true";
                    ;;
        buster)     duo_repo_url="http://pkg.duosecurity.com/Debian buster main";
                    duo_supported="true";
                    ;;
        *)          _log_warn "Only LTS/Stable versions of Ubuntu/Debian are suported."
                    _log_warn "You are running Unsupported version : ${code_name}"
                    ;;
      esac
      if [[ $duo_supported == "true" ]]; then
        # Repo keys for duosecurity
        _log_debug "Downloading GPG key..."
        wget -q https://duo.com/DUO-GPG-PUBLIC-KEY.asc  -O /tmp/ae/duosecurity.gpg >> "$log_file"
        apt-key add /tmp/ae/duosecurity.gpg |& _log_trace "${_phase_apt_key}" \
        || _log_error "Adding Duo Key Failed"

        # Add repo
        echo "deb [arch=$ARCH] ${duo_repo_url} #Duo Unix"  > ${SOURCES_FILE_DIR}/duounix.list
      else
        _log_error "Duo for Unix is not supported on this distribution!"
      fi
    else
      _log_info "Duo Unix is set to false."
    fi

  # End if ARCH==64 Check
  fi

  #Wine HQ
  if [ "$add_winehq_repo" == "true" ]; then
    _log_info "WineHQ"
    _log_debug "Getting WineHQ repository Key"
    wget -q https://dl.winehq.org/wine-builds/winehq.key -O /tmp/ae/wine-hq-sigining-key.key >> "$log_file"  2>&1
    _log_debug "Adding WineHQ key"
    apt-key add /tmp/ae/wine-hq-sigining-key.key |& _log_trace "${_phase_apt_key}" \
    || _log_error "Adding WineHQ keys failed"
    _log_debug "Adding WineHQ repository"
    echo "deb https://dl.winehq.org/wine-builds/${distro_name}/ ${code_name} main #WineHQ" > ${SOURCES_FILE_DIR}/winehq.list \
    || _log_error "Adding WineHQ repository failed"
  else
    _log_info "Skipped WineHQ."
  fi

  # Docker CE
  if [ "$add_docker_repo" == "true" ]; then
    if [ "$ARCH" == "amd64" ] || [ "$ARCH" == "armhf" ]; then
      _log_info "Adding Docker-CE"
      __add_repo_keys --name "Docker-CE" \
        --format "asc" \
        --file-prefix "docker-ce" \
        --key-url https://download.docker.com/linux/"${distro_name}"/gpg
      _log_debug "Adding Docker-CE sources .list"
      echo "deb [arch=$ARCH signed-by=/usr/share/keyrings/docker-ce.gpg] https://download.docker.com/linux/${distro_name}  ${code_name} stable #Docker-Community-Edition" > ${SOURCES_FILE_DIR}/docker.list \
      || _log_error "Adding Docker-CE repository failed"
    else
      _log_error "Architecture not supported!. Please use docker.io package from your distro."
    fi
  else
    _log_debug "Skipped Docker-CE"
  fi

  # Github CLI
  #gh

  if [ "$add_gh_repo" == "true" ]; then
    _log_info "GitHub CLI(gh)"
    _log_debug "Adding Key to trusted GPG keys directory"
    apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C99B11DEB97541F0 |& _log_trace "${_phase_apt_key}" \
   || _log_error "Adding Github CLI keys failed"
    echo "deb https://cli.github.com/packages  ${code_name}  main #GitHub-CLI" > ${SOURCES_FILE_DIR}/github-cli.list
  else
    _log_debug "Skipped GitHub CLI(gh)."
  fi

  # Hashicorp
  if [ "$add_hashicorp_repo" == "true" ]; then
    if [ "$ARCH" == "amd64" ]; then
      _log_info "Hashicorp APT repository"
      __add_repo_keys --name "Hashicorp" \
        --format "asc" \
        --file-prefix "hashicorp" \
        --key-url https://apt.releases.hashicorp.com/gpg
      echo "deb [arch=amd64 signed-by=/usr/share/keyrings/hashicorp.gpg] https://apt.releases.hashicorp.com ${code_name} main#Hashicorp-Packages" > ${SOURCES_FILE_DIR}/hashicorp.list
    else
      _log_error "Hashicorp repositories are not supported on this architecture[$ARCH]!"
    fi
  else
    _log_debug "Skipped adding Hashicorp repos"
  fi


  # Gvisor container Runtime
  if [[ $add_gvisor_repo == "true" ]]; then

    if [[ $ARCH == "amd64" ]] ||  [[ $ARCH == "arm64" ]]; then
      _log_info "Adding Gvisor Reposiory"

      # Adding Gvisor Keys
      __add_repo_keys --name "Gvisor Container Runtime" \
        --format "asc" \
        --file-prefix "gvisor" \
        --key-url https://gvisor.dev/archive.key
      echo "deb [arch=$ARCH signed-by=/usr/share/keyrings/gvisor.gpg] https://storage.googleapis.com/gvisor/releases release main #Gvisor-Container-Runtime"  > ${SOURCES_FILE_DIR}/gvisor.list \
      || _log_error "Adding Gvisor repository failed!"
    else
      _log_error "Gvisor runtime is not supported on this architecture(${ARCH})"
      _log_dev "See https://gvisor.dev/ for more info"
    fi

  else
    # Gvisor is not enabled
    _log_debug "Skipped addinng Gvisor repository."
  fi


  # ROS
  # Arch support varies on distro so lot of ugly elifs.
  ros_arch_supported="false"

  if [[ $add_ros_repo == "true" ]] && [[ ${bool_codename_fix_appied} == "true" ]]; then
    _log_info "Checking compatibility for ROS"
    _log_error "You have enabled --fix or --pre-release option."
    _log_error "ROS depends heavily on packages included in the distribution."
    _log_error "ROS repositories will not be added for sanity of your system!"

  elif [[ $add_ros_repo == "true" ]] && [[ ${bool_codename_fix_appied} == "false" ]]; then

    _log_info "Checking compatibility for ROS"

    # Distro/Version/Arch checks
    if [[ $distro_name == "ubuntu" ]]; then
      if [[ $code_name == "bionic" ]]; then
        ros_arch_supported="true"
        _log_success "ROS is available on Bionic/$ARCH"
      elif [[ $code_name == "xenial" ]]; then
        ros_arch_supported="true"
        _log_success "ROS is available on Xenial/$ARCH"
      elif [[ $code_name == "focal" ]]; then
        ros_arch_supported="true"
        _log_success "ROS is available on Focal/$ARCH"
      fi
    fi #ubuntu

    if [ "$distro_name" == "debian" ]; then
      # Check architectures
      if [[ $code_name == "stretch" ]] || [[ $code_name == "buster" ]]; then
        ros_arch_supported="true"
        _log_success "ROS is available on Debian ${code_name}/$ARCH"
      fi
    fi #debian

    if [[ $ros_arch_supported == "true" ]]; then
      _log_info "Adding ROS repositories"
      _log_debug "Adding ROS repo key (latest)"
      apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 |& _log_trace "${_phase_apt_key}"  \
       || _log_error "Adding ROS repository key failed!"

      if [[ $bool_use_uf_mirror == "true" ]]; then
        _log_warn "UF ROS Repo is no loger syncing with upstream."
        _log_warn "This feature will be enabled once the mirror is back in sync!"
        _log_warn "Till then, upstream is being used!"
      fi

      echo "deb http://packages.ros.org/ros/ubuntu ${code_name} main #ROS-Repo" > $SOURCES_FILE_DIR/ros-latest.list \
        || _log_error "Adding ROS repository failed!"
    else
      _log_error "ROS is not supported on this distro!"
    fi # ros_arch_supported

  else
    _log_debug "Skipped ROS"
  fi # add_ros_repo


  # Enable Canonical Partner repos
  # Some Releases like linux mint have their own way of enabling partner repositories,
  # Disable adding partner Repositoris when using Ubuntu Derivatives like Linux Mint.
  # Default is true
  # _fix_ubuntu_derivatives will take care of this and bool_config_partner_repo is set to true only if
  # Ubuntu and its flavors are used.
  if [ "$bool_config_partner_repo" == "true" ] && [ "$bool_is_debian" != "true" ]; then
    _log_info "Canonical partner repositoris"
    echo "deb http://archive.canonical.com/ubuntu $code_name partner #Canonical Partner Repository"  > ${SOURCES_FILE_DIR}/canonical-partner.list \
    || _log_error "Failed to add Canocial Parner Repos."
  else
    _log_warn "Canonical Partner repositories may not be supported on this platform."
  fi


  # Remove artifacts and keys
  _log_debug "Removing keys and converted files from current directory"
  (
    rm  -f /tmp/ae/*.gpg /tmp/ae/*.asc /tmp/ae/*.pub /tmp/ae/Release \
        /tmp/ae/*.Release /tmp/ae/*.key /tmp/ae/*.pub.* /tmp/ae/*.asc.* \
        /tmp/ae/*.key.* /tmp/ae/*.gpg.* >> "$log_file"
  )

  update_repos

}


function __fix_permissions()
{

  # Fix permissions
  # Expects 2 args
  # Arg 1 : Path to check
  # Arg 2 : Permission in octal

  local check_path expected_permissions
  local path_attrs


  if [[ $# -lt 2 ]]; then
    _log_and_exit "Internal Error in ${FUNCNAME[0]}, expected 2 args, got $#" "19"
  fi

  check_path="${1}"
  expected_permissions="${2}"

  # check if pat exists
  if [[ ! -e ${check_path} ]]; then
    _log_error "Internal Error in ${FUNCNAME[0]}, path(${check_path}) not found!"
    # immediately return
    return
  fi

  # check if attributes are valid
  if [[ ! ${expected_permissions} =~ ^[4-7][04-7][04-7]$ ]]; then
    _log_error "Expected permissions are invalid(${expected_permissions})"
    _log_and_exit "Internal Error! in ${FUNCNAME[0]}" "19"
  fi

  # check permissions and fix it
  path_attrs="$(stat -L -c %a "${check_path}")"
  if [[ ${path_attrs} != "${expected_permissions}" ]]; then
    _log_warn "${check_path} has INCORRECT permissions(${path_attrs})!"
    if chmod "${expected_permissions}" "${check_path}" |& _log_trace "${_phase_apt_key}" ; then
      _log_success "Fixed!"
    else
      _log_error "Failed to fix permissions!"
      # immediately return
      return
    fi
  else
    _log_debug "${check_path} has expected permissions(${expected_permissions})."
  fi
}


function __add_repo_keys()
{
  if [[ $# -ne 8 ]]; then
    _log_and_exit "Internal Error! Expected 8 args (got $#) for ${FUNCNAME[0]}!" "19"
  fi

  local exit_code
  local key_url key_file_prefix key_format key_repo_name
  local curl_output_file

  while [ "${1}" != "" ]; do
    case ${1} in
      -n | --name)          shift;key_repo_name="${1}"
                            ;;
      -k | --key-url)       shift;key_url="${1}"
                            ;;
      -p | --file-prefix)   shift;key_file_prefix="${1}"
                            ;;
      -f | --format)        shift;key_format="${1}"
                            ;;
      *)                    _log_and_exit "Invalid internal function arguments for ${FUNCNAME[0]}!" "19"
                            ;;
    esac
    shift
  done

  _log_property "Repository Name" "${key_repo_name}"
  _log_property "Key file URL"    "${key_url}"
  _log_property "Key file Format" "${key_format}"
  _log_property "Key file name"   "${key_file_prefix}.${key_format}"

  # check if format is valid
  if [[ ! ${key_format} =~ ^(gpg|asc)$ ]]; then
    _log_and_exit "Internal Error in ${FUNCNAME[0]} -f/--format can only accept gpg or asc[${key_format}]/" "19"
  fi

  # check if --name is empty
  if [[ -z ${key_repo_name} ]]; then
    _log_warn "Internal Error in ${FUNCNAME[0]} --name (apt-key) is empty!"
    key_repo_name="${key_file_prefix}"
  fi


  # check if file prefix is valid
  # shellcheck disable=SC1001
  if [[ ! ${key_file_prefix} =~ ^[a-zA-Z][a-zA-Z.\-]+[a-zA-Z0-9]$ ]]; then
    _log_and_exit "Internal Error in ${FUNCNAME[0]}  --file-prefix is invalid!" "19"
  fi

  if [[ ! ${key_url} =~ ^https:// ]]; then
    _log_error "APT Key URL does not start with https://."
    _log_error "Got (${key_url})!"
    _log_and_exit "Internal Error in ${FUNCNAME[0]} APT key URL is invalid!" "19"
  fi

  # check if /usr/share/keyrings is present
  if [[ ! -d /usr/share/keyrings ]]; then
    _log_error "/usr/share/keyrings/ is missing!!"
    _log_and_exit "Your installation of ${AE_DISTRO_NAME} is broken!" "64"
  fi


  # fetch key
  if [[ -e /usr/share/keyrings/${key_file_prefix}.gpg ]]; then
    _log_warn "GPG Key file ${key_file_prefix}.${key_format} already exists!"
    _log_warn "Script will *NOT* overwrite it to avoid deleting keys!"
  else
    _log_info "Fetching ${key_repo_name} keys"

    curl -sSfL -m 20 -o "/usr/share/keyrings/${key_file_prefix}.${key_format}" "${key_url}" |& _log_trace "${_phase_apt_key}"
    exit_code="$?"
    if [[ $exit_code -eq 0 ]]; then
      _log_success "OK"
    else
      _log_error "Failed to fetch ${key_repo_name}!"
    fi
  fi

  # check if file has correct permissions
  __fix_permissions "/usr/share/keyrings/${key_file_prefix}.${key_format}" "644"

  # check if file needs to be converted
  if [[ ${key_format} == "asc" ]]; then

    _log_debug "Key is in ascii armored format. Converting it."
    if [[ -e "/usr/share/keyrings/${key_file_prefix}.gpg" ]]; then
      _log_warn "Dearmored file already exists!"
      _log_warn "Script will *NOT* overwrite it to avoid deleting keys."
    else
      gpg --dearmor --output "/usr/share/keyrings/${key_file_prefix}.gpg" "/usr/share/keyrings/${key_file_prefix}.asc" |& _log_trace "${_phase_apt_key}"
      exit_code="$?"
      if [[ $exit_code -eq 0 ]]; then
        _log_debug "Successfully converted ascii armored GPG key file."
      else
        _log_error "Failed to convert ascii armored GPG key file."
      fi
    fi

    # check and fix permissions
    __fix_permissions "/usr/share/keyrings/${key_file_prefix}.gpg" "644"

  else
    _log_debug "No need to convert key file."
  fi

}


function update_repos()
{
  local exit_status
  _log_info "Running apt-get update"
  apt-get -q -o=Dpkg::Use-Pty=0 update |& _log_trace "${_phase_apt}"
  exit_status=$?
  if [[ $exit_status -eq 0 ]]; then
    _log_success "Success!"
  else
    _log_error "Command apt-get update failed and exited with ${exit_status}"
    _log_error "In most cases its either missing repo keys or wrongly configured repositories."
    _log_error "Fix then and re run the script."
    _log_and_exit "The script cannot proceed with this error." "61"
  fi
}

function update_repos_as_task()
{
  _log_stage "Update repository metadata"
  update_repos
}

function upgrade_apps()
{
  # This function will list up-gradable apps and upgrade it.
  # IF Simulate is set to true this will only list the apps but no upgrade action will be performed.
  local exit_status
  _log_stage "Upgrade Packages..."
  _log_info "Checking and upgrading packages"
  # upgradable is not available in apt-get ignore warning about apt being unstable
  apt list --upgradable |& _log_trace "${_phase_apt}"  \
  || _log_info "Something went wrong while listing upgradable packages. Please see the log file or run in debug mode for details."

  # only do upgrades if simulate is set to false
  if [ "$simulate_apt_install" != "true" ]; then

    DEBIAN_FRONTEND=noninteractive apt-get -q -o=Dpkg::Use-Pty=0 -y upgrade |& _log_trace "${_phase_apt}"
    DEBIAN_FRONTEND=noninteractive apt-get -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" --allow-remove-essential --allow-change-held-packages -fuy dist-upgrade \
    | _log_trace "${_phase_apt}"
    exit_status=$?
  else
    # If  simulate is true, set exit status as 0
    # Simulate flag skips the section above. No point in Checking for exit status
    _log_warn "Simulate is set to True. Not performing upgrade!"
    exit_status=0
  fi
  if [[ $exit_status -eq 0 ]]; then
    _log_success "Completed"
  else
    _log_error "Something went wrong while upgrading packages."
    _log_error "Please see the log file for more details."
    _log_error "Most of the times its either missing keys or wrongly configured repositories."
  fi
  # Cleanup APT cache (-k)
  _clean_apt_cache;


}


function  upgrade_system()
{
  _log_stage "Update repository index/metadata... "
  update_repos;
  upgrade_apps;
}


function purge_ppa()
{
  # PPAs added or repositories added by actions other than this script are not removed.
  # Simulate option has no effect on this function. PPAs will be purged irrespective of its value.
  local exit_status index dependency_packages
  dependency_packages=(ppa-purge)

  if [ "$enable_ppa" == "true" ]; then
    _log_stage "Purge PPAs"
    _install_dependencies "${dependency_packages[@]}"
      for index in "${parsed_ppa_list[@]}"; do
            _log_info "$index..."
            _log_debug "Purging: $index"
            if [ "$index" == "" ] || [ "$index" == " " ]; then
              _log_warn "Found an empty entry, Ignoring"
              continue;
            fi
            if ppa-purge -y "$index"  |& _log_trace "${_phase_purge}"  ; then
              sleep 5 #wait sometimes apt lock isnt released soon.
              _log_success "$line purged."
            else
              _log_error "Some Error occured while purging $line."
            fi
        done
      # Clean -k flag.
      _clean_apt_cache;
      _log_success "Purging PPAs completed"

  else
    _log_warn "PPA's are not available for this release/distro"
  fi
}


function disable_external_repos()
{
  # Function to disable external repositories added by this script.
  # PPAs added or repositories added by actions other than this script are not removed.
  # Repositories added by dpkg post install scripts and deb files will not be removed!!
  # Simulate option has no effect on this function. PPAs will be purged irrespective of its value.

    # Remove keys and list files.
    _log_stage "Deleting Keys and external repositories"
    _log_notice "You can igore failed messages if those were not added in first place."

    _log_info "Deleting Google signing key   7FAC5991"
    apt-key del 7FAC5991  |& _log_trace "${_phase_apt_key}"  \
    || _log_warn "Deleting Google signing key -1 failed."

    _log_info "Deleting Google signing key   D38B4796"
    apt-key del D38B4796  |& _log_trace "${_phase_apt_key}"  \
    || _log_warn "Deleting Google signing key -2 failed."

    _log_info "Deleting GCP signing key -2   BA07F4FB"
    apt-key del BA07F4FB  |& _log_trace "${_phase_apt_key}"  \
    || _log_warn "Deleting Google cloud key -1 failed."

    _log_info "Deleting GCP signing key -2   A7317B0F"
    apt-key del A7317B0F  |& _log_trace "${_phase_apt_key}"  \
    || _log_warn "Deleting GCP signing key -2  failed."

    _log_info "Deleting Spotify signing key  E130D1D45"
    apt-key del E130D1D45  |& _log_trace "${_phase_apt_key}"  \
    || _log_warn "Deleting Spotify signing key failed."

    _log_info "Deleting WineHQ key [latest]  F987672F"
    apt-key del F987672F  |& _log_trace "${_phase_apt_key}"  \
    || _log_warn "Deleting WineHQ keys [latest] failed."

    _log_info "Deleting InSync signing key   ACCAF35C"
    apt-key del ACCAF35C  |& _log_trace "${_phase_apt_key}"  \
    || _log_warn "Deleting InSync keys failed."

    _log_info "Deleting Docker signing key   0EBFCD88"
    apt-key del 0EBFCD88  |& _log_trace "${_phase_apt_key}"  \
    || _log_warn "Deleting Docker-CE keys failed."

    _log_info "Deleting VS-Code signing key  BE1229CF"
    apt-key del BE1229CF  |& _log_trace "${_phase_apt_key}"  \
    || _log_warn "Deleting Visual Studio Code keys failed."

    _log_info "Deleting Signal signing key   57F6FB06"
    apt-key del 57F6FB06  |& _log_trace "${_phase_apt_key}"  \
    || _log_warn "Deleting Signal keys failed."

    _log_info "Deleting Mendeley signing key 6F036044"
    apt-key del 57F6FB06  |& _log_trace "${_phase_apt_key}"  \
    || _log_warn "Deleting Mendeley Desktop keys failed."

    _log_info "Deleting ROS signing key B01FA116"
    apt-key del 421C365BD9FF1F717815A3895523BAEEB01FA116  |& _log_trace "${_phase_apt_key}"  \
    || _log_warn "Deleting ROS keys failed."

    _log_info "Deleting GitHub-CLI Repo signing key C99B11DEB97541F0"
    apt-key del C99B11DEB97541F0  |& _log_trace "${_phase_apt_key}"  \
    || _log_warn "Deleting GitHub-CLI Repo keys failed."

    _log_info "Deleting Hashicorp signing key DA418C88A3219F7B"
    apt-key del DA418C88A3219F7B  |& _log_trace "${_phase_apt_key}"  \
    || _log_warn "Deleting Hashicorp key failed."

    _log_info "Removing external repositoris"
    _log_debug "Deleting *.list and *.save files from ${SOURCES_FILE_DIR}"
    (
      cd /etc/apt/sources.list.d &&
        rm  -f google-chrome.* \
        google-earth.* \
        skype-stable.* \
        spotify.* \
        insync.* \
        google-cloud-sdk.* \
        gcsfuse.* \
        docker.* \
        winehq.* \
        vscode.* \
        signal-xenial.* \
        mendeleydesktop.* \
        gh-cli.* \
        ros-latest.* \
        hashicorp.* \
        gvisor.*
    )
    exit_status=$?

    if [[ $exit_status -eq 0 ]]; then
      _log_notice "Removed additional APT keys and repositories."
      _log_notice "Canonical partner repository was left unchanged."
    else
      _log_warn "Failed to remove all or some of the list files or keys in Sources directory."
      _log_warn "Please see the log file for more details."
    fi
    _log_notice "Removed repositories. Please check the logs for errors."



}

function purge_not_required()
{
  # This function purges not required packages from the list ${dir}/data/purge.list
  # A flag -d MUST be passed for this option to work
  # Not passing a flag and choosing purge will result in error and action being aborted.
  # Simulate is not properly tested and use it with caution!
  # Combination of simulate and purge is UNSTABLE
  # You can modify -d requirement by setting the d_flag_passed=true
  # No validation/checks are done on the list file.
  # Action is dangerous if used carelessly eg. If you are stupid and remove say sudo (why would you??)

  local exit_status
  if [ "$bool_purge_pkgs" == "true" ]; then
    _log_stage "Purge packages..."

    if [[ ${#parsed_purge_packages[@]} -eq 0 ]]; then
      _log_error "Packages to purge is empty!";
      return;
    else
      if [ "$simulate_apt_install" == "true" ]; then
        _log_warn "Purging packages will be simulated!!"
      apt-get -q -o=Dpkg::Use-Pty=0 -y remove --purge --dry-run "${parsed_purge_packages[@]}" |& _log_trace "${_phase_apt}"
      else
        apt-get -q -o=Dpkg::Use-Pty=0 -y purge "${parsed_purge_packages[@]}" |& _log_trace "${_phase_apt}"
      fi
      exit_status=$?

      if [[ $exit_status -eq 0 ]]; then
        _log_success "Done!"
      else
        _log_error "Something went wrong while purging packages."
        _log_error "Please see the log file for more details."
      fi
    fi

  else
    _log_and_exit "Purge switch is set to false. Did you pass -d along with the command?" "20"
  fi


}


function install_apps()
{
  # Function to install apps mentioned in arrays
  # external-repos should always be at last to avoid any errors in previous .
  # No checks are being made on any of the files for validity. One entry per line is recommended.
  # If a package is not available entire collection in the file *.list will not be installed!!

  # Accept some EULA
  update_repos;

  _log_stage "Install packages"

  echo ttf-mscorefonts-installer msttcorefonts/accepted-mscorefonts-eula select true |  debconf-set-selections
  #Install starts here
  local packages exit_status index
  #shellcheck disable=SC2034
  readonly local package_arrays=(
                              administration
                              security
                              productivity
                              multimedia
                              development
                              other
                              external
                              )
  for array in "${package_arrays[@]}"; do
    case "${array}" in
      administration)         packages=("${parsed_administration_packages[@]}");;
      security)               packages=("${parsed_secutity_packages[@]}");;
      productivity)           packages=("${parsed_productivity_packages[@]}");;
      multimedia)             packages=("${parsed_multimedia_packages[@]}");;
      development)            packages=("${parsed_development_packages[@]}");;
      other)                  packages=("${parsed_other_packages[@]}");;
      external)               packages=("${parsed_external_packages[@]}");;
      *)                      _log_and_exit "Internal error. Invalid array type" "19";;
    esac

    # Chek if array is empty
    if [[ ${#packages[@]} -eq 0 ]]; then
      _log_debug "Ignoring empty list of packages in $array";
      continue
    else
      _log_info "Installing $array packages"
      # Check if simulate is true
      if [ "$simulate_apt_install" == "true" ]; then
        _log_warn "Simulating package installation."
        apt-get -q -o=Dpkg::Use-Pty=0 -y install -s "${packages[@]}" | _log_trace "${_phase_apt}"
      else
        apt-get -q -o=Dpkg::Use-Pty=0 -y install "${packages[@]}" | _log_trace "${_phase_apt}"
      fi
      exit_status=$?
      unset packages;
      if [[ $exit_status -eq 0 ]]; then
        _log_success "Done!"
      else
      _log_error "Something went wrong while installing packages in set - $array."
      _log_error "Please see the log file for more details."
      fi

    fi
    unset packages
  done
  # Delete DEBs
  _clean_apt_cache;


}


function _install_pip_python()

{
  # Function to install python pip packages
  # This function reads from File ${dir}/data/pip.list contains list python packages to be installed system wide.
  # Arguments : Two
  # ARG1 : pip package list
  # ARG2 : 2 for python 2 and
  #      : 3 for Python 3.

  #Check args
  if [ $# -lt 1 ] ||  [ $# -gt 1 ] ; then

    _log_error "Incorrect number of arguments."
    _log_and_exit "Internal Error. Invalid number of Arguments: $#." "19";
  fi;


  #Install starts here
  local exit_status pip_command pip_loc python_packages requirements_file
  local pip_ver="${1}"
  _log_debug "Option: Install Python packages via PIP, Function name: _install_pip_python"
  _log_debug "pip Version : ${pip_ver}"

  # Check Python Version
  case ${pip_ver} in
    2 | python2 )   readonly pip_command="pip"
                    dependency_packages=(python-pip python-setuptools)
                    python_packages=("${parsed_pip2_packages[@]}")
                    requirements_file="/tmp/ae/requirements2.txt"
                    ;;
    3 | python3 )   readonly pip_command="pip3";
                    dependency_packages=(python3-pip python3-setuptools)
                    python_packages=("${parsed_pip3_packages[@]}")
                    requirements_file="/tmp/ae/requirements3.txt"
                    ;;
              * )   _log_and_exit "Internal Function Error. Arguments for python version." "19";;
  esac

  _log_info "Install dependencies for python: ${pip_ver}"

  # Check if `python-pip` is installed, if not install it
  if ! pip_loc="$(type -p "$pip_command")" || [[ -z $pip_loc ]]; then
      _log_debug "$pip_command is not installed!${NC}"
      update_repos;
      _log_info "Install PIP dependencies"

      # Check if simulate flag is set
      if [ "$simulate_apt_install" == "true" ] && [ "$AE_INTERNAL_CI_MODE" != "true" ]; then
        _log_warn "Simulating! No Dependencies will be installed!!"
        # shellcheck disable=SC2086
        apt-get -q -o=Dpkg::Use-Pty=0 -y -s --no-install-recommends install "${dependency_packages[@]}" |& _log_trace "${_phase_apt}"
      elif [ "$simulate_apt_install" == "true" ] && [ "$AE_INTERNAL_CI_MODE" == "true" ]; then
        _log_dev "This is CI disregarding --simulate flag"
        apt-get -q -o=Dpkg::Use-Pty=0 -y --no-install-recommends install "${dependency_packages[@]}" |& _log_trace "${_phase_apt}"
      else
        # shellcheck disable=SC2086
        apt-get -q -o=Dpkg::Use-Pty=0 -y --no-install-recommends install "${dependency_packages[@]}" |& _log_trace "${_phase_apt}"
      fi
      exit_status=$?

      if [[ $exit_status -eq 0 ]]; then
        _log_success "Done"
      else
        _log_error "Something went wrong while installing dependencies."
        _log_error "Python packages cannot be installed without dependencies."
        _log_and_exit "Please see the log file for more details." "21"
      fi

      ## honor --keep-debs -k flags
      _clean_apt_cache;

  else
    _log_success "dependencies already satisfied."
  fi
  # reset exit status & color
  exit_status=0


  _log_info "Installing python packages"
  _log_debug "Requirements file: ${requirements_file}"
   rm -f ${requirements_file} || _log_and_exit "Failed to remove ${requirements_file}" "38"
   printf "%s\n" "${python_packages[@]}" > "${requirements_file}"
  # Check if pip package list is empty
  if [[ ${#python_packages[@]} -eq 0 ]]; then
    _log_error "Package array is empty!";
    return
  else
    # I package list isn't empty proceed to install pip packages
    # Check if simulate is true & is not running on TRAVIS/CI.
    if [ "$simulate_apt_install" == "true" ] && [ "$AE_INTERNAL_CI_MODE" != "true" ]; then
      _log_warn "PIP does not support simulated installs. Not performing install."
    elif  [ "$simulate_apt_install" == "true" ] && [ "$AE_INTERNAL_CI_MODE" == "true" ]; then
      _log_dev "This is CI disregarding --simulate flag!"
      $pip_command install -r "${requirements_file}" |& _log_trace "${_phase_pip}"
    else
      _log_debug "Installing requirements file ${requirements_file}"
      $pip_command install -r "${requirements_file}" |& _log_trace "${_phase_pip}"

    fi
    exit_status=$?
    if [[ $exit_status -eq 0 ]]; then
      _log_success "Done Python ${pip_ver}"
    else
      _log_error "Something went wrong while installing Python $pip_ver packages."
      _log_error "Please see the log file for more details."
    fi
  fi


}


function install_pip_packages_2()
{
  _log_stage "Python 2 Packages"
  # Install Python 2 packages
  _log_info "Check if platform supports python2"
  if [[ $python2_disabled == "true" ]]; then
    _log_error "Python 2 is not supported on this platform!"
  else
    _log_success "Python 2 is still supported on your distro"
    _install_pip_python "2"
  fi
}


function install_pip_packages_3()
{
  # Install Python 2 packages
  _log_stage "Python 3 Packages"
  _install_pip_python "3"
}


function install_debs ()
{

  # Function to get the deb files from DEB_URL in the ${dir}/data/deb_files.list
  # The list file has following format
  # URL to get the deb file  <space or tab> NAME_OF_THE_APP(without spaces)

  _log_stage "Install DEB packages"
  local index deb_url line deb_file_name
  local exit_status
  _log_debug "Option: Install DEB Files, Function name: install_debs"
  for index in "${parsed_deb_files_list[@]}"; do
    deb_url=$(echo "$index" | cut -d ',' -f1 )
    deb_file_name=$(echo "$index" | cut -d ',' -f2 )
    _log_var "deb_url"
    _log_var "deb_file_name"

    if [[ -z $deb_url ]] || [[ -z $deb_file_name ]]; then
      _log_error "Malformed entry either URL or name is empty!"
      continue
    fi

    _log_info "Downloading - $deb_file_name"
    {
      wget -q "$deb_url" -O "${deb_file_name}" >> "$log_file"
    } ||
    {
      _log_error "Downloading $deb_file_name failed."
      continue
    }

   _log_info "Installing  - $deb_file_name..."
   # Check if simulate is true
   if [ "$simulate_apt_install" == "true" ]; then
     _log_warn "Simulating $deb_file_name Installation!!"
     dpkg -i --dry-run "$deb_file_name" |& _log_trace "${_phase_deb}"

     _log_debug "Installing missing packages..."
     apt-get -q -o=Dpkg::Use-Pty=0 -y install -f |& _log_trace "${_phase_apt}"
     exit_status=$?
    else
      dpkg -i "$deb_file_name" |& _log_trace "${_phase_deb}"
      _log_debug "Installing missing packages..."
      apt-get -q -o=Dpkg::Use-Pty=0 -y install -f |& _log_trace "${_phase_apt}"
      exit_status=$?
    fi

    # shellcheck disable=SC2181
     if [ "$exit_status" = "0" ]; then
      _log_success "Done"
     else
      _log_error "Some error occurred during downloading and installing $index."
      $?="0"
    fi
    # Delete DEBs
    if [ "$bool_preserve_debs" == "false" ];then
      _log_debug "Clean up downloaded packages"
      (
        rm -f "${dir}/${deb_file_name}" >> "$log_file"
      )
    else
      _log_notice "Keeping downloaded packages"
    fi
  done

  _clean_apt_cache;

}


function install_binaries ()
{

  # Function to get the binaries files from URL in the ${dir}/data/bin.list
  # The list file has following format
  # <URL>,<filename>
  # If you want to specify relative path you
  # can do so relative to /usr/local/bin
  # Be careful not to rename existing ones
  _log_stage "Install static binaries"

  local index bin_url line bin_name
  local exit_status
  _log_debug "Option: Install Bin Files, Function name: install_binaries"
  # Check if simulate is true
  for index in "${parsed_bin_packages[@]}"; do
    bin_url=$(echo "$index" | cut -d ',' -f1 )
    bin_name=$(echo "$index" | cut -d ',' -f2 )
    _log_var "bin_url"
    _log_var "bin_name"

    if [[ -z $bin_url ]] || [[ -z $bin_name ]]; then
      _log_error "Malformed entry either URL or name is empty!"
      continue
    fi
    _log_info "Downloading - $bin_name"
    wget -q "$bin_url" -O "/tmp/ae/${bin_name}" >> "$log_file"
    exit_status="$?"
    if [ $exit_status -eq 0 ]; then
      _log_success "OK"
      _log_info "Installing  - $bin_name"
       if [ "$simulate_apt_install" == "true" ]; then
         _log_warn "Skipping install"
       else
        {
          cp -rf "/tmp/ae/${bin_name}" /usr/local/bin/"${bin_name}"
        } || _log_error "Failed to copy $bin_name";
        _log_debug "Setting Permissions..."
        chmod +x /usr/local/bin/"$bin_name" >> "${log_file}"
      fi
    else
      _log_error "Failed to download $bin_name."
    fi
  done

}


function __install_snaps()
{
  #Install Snap packages
  local exit_status index snapd_options
  local snap_type
  snap_type="$1"

  case ${snap_type} in
    classic)    snapd_options=("--color=never" "--classic")
                parsed_snaps_list=("${parsed_snap_classic_packages[@]}")
                ;;
    edge)       snapd_options=("--color=never" "--edge")
                parsed_snaps_list=("${parsed_snap_edge_packages[@]}")
                ;;
    normal)     snapd_options=("--color=never")
                parsed_snaps_list=("${parsed_snap_normal_packages[@]}")
                ;;
    * )         _log_and_exit "Internal Function Error. Arguments for snap type." "19";;
  esac

  if [[ ${#parsed_snaps_list[@]} -eq 0 ]]; then
      _log_warn "Snaps array is empty!" "19"
  else
    for index in "${parsed_snaps_list[@]}"; do
      _log_info "Installing snap - $index"
      if [ "$index" == "" ] || [ "$index" == " " ]; then
        _log_warn "Found an empty entry, Ignoring"
        continue;
      fi

      if [ "$simulate_apt_install" == "true" ]; then
        _log_warn "Snaps do not support --dry-run, skipping installation"
      else
        _log_debug "Options are ${snapd_options[*]}"
        if snap install "${snapd_options[@]}" "$index"  |& _log_trace "${_phase_snap}"  ; then
          _log_success "$line installed successfully."
        else
          _log_error "Failed!"
        fi
      fi
    done
  fi
}


function install_snaps()
{
  local dependency_packages
  dependency_packages=(snapd)

  if [ "$simulate_apt_install" == "true" ]; then
    _log_warn "Will not install dependencies required for installing snap packages"
  else
    _install_dependencies "${dependency_packages[@]}"
  fi

  _log_stage "Install snap packages"
  __install_snaps "normal"
  _log_stage "Install classic snap packages"
  __install_snaps "classic"
  _log_stage "Install beta snap packages"
  __install_snaps "edge"

}

function _autopilot_check_task_flag_and_run()
{
  # checks flags set for each task/function and runs it
  # Arguments Two
  # ARG -1 : global flag variable to check
  # ARG -2: Function Name to execute
  local flag=${1}
  local runnable=${2}

  if [ "${flag}" == "true" ]; then
    _log_debug "Executing Function $runnable"
    "$runnable"
  else
    _log_debug "Task : $runnable is not enabled"
  fi
  unset runnable
}


function all_in_one()
{
  #Wrapper for all options
  _log_debug "Option: ALL IN ONE, function name: all_in_one"
  update_repos_as_task;
  upgrade_apps;
  add_ppas;
  add_repositories;
  install_apps;
  install_debs;
  install_pip_packages_2;
  install_pip_packages_3;
  purge_not_required;
  install_binaries;
  install_snaps;

}


function _prompt_confirmation()
{
  # Function to confirm whether action selected should be performed or not.
  # Accepts 2 arguments
  # ARG-2 Message to be displayed in confirmation box
  # ARG-2 name of the function to execute
  # Depends on whiptail
  # To overide and say yes to all dialog pass -y as command line option while running the script.
  local confirm_msg="${1}" #Message shown in Confirmation dialogue
  local exec_function="${2}" #Function to run if user selected yes
  COLUMNS=$(tput cols)
  LINES=$(tput lines)
  export COLUMNS LINES
  if [ "$bool_say_yes_to_all" == "true" ]; then
    _log_debug "Yes to all: No confirm dialog to be displayed."
    _log_debug "Executing: $exec_function"
    $exec_function;
  else
    _log_debug "Confirming  $exec_function."
    # shellcheck disable=SC2086
    if (whiptail  --title "Ubuntu Post-Install Script"  --yesno "$confirm_msg" $LINES $COLUMNS $(( LINES - 12 ))) then
        # execute the function
        _log_debug "Executing: $exec_function"
        $exec_function
    else
        _log_debug "Selected No for $name_of_task, Returning to main menu."
        _process_menu;
    fi
  fi
  unset exec_function
}


function _process_menu()
{
  local whiptail_exitstatus task COLUMNS LINES
  _log_debug "Displaying Main menu"
  COLUMNS=$(tput cols)
  LINES=$(tput lines)
  #export COLUMNS LINES
  # shellcheck disable=SC2086
  task=$(whiptail \
      --notags \
      --backtitle "$SCRIPT" \
      --title "Ubuntu Post-Install Script" \
      --menu "\nWhat would you like me to do?" \
      --cancel-button "Quit" \
      $LINES $COLUMNS $(( LINES - 12 )) \
      update     'Update Repository Metadata' \
      upgrade    'Upgrade Packages' \
      repo       'Add Repositories' \
      ppas       'Add PPAs' \
      purge      'Purge not required packages' \
      apps       'Install Packages' \
      debs       'Install DEB packages' \
      pip2       'Install Python 2 packages via pip' \
      pip3       'Install Python 3 packages via pip3' \
      bin        'Download & Install Static Binaries' \
      snaps      'Install snap packages' \
      all        'All the tasks mentioned above' \
      repo_rst   'Reset Repositories for cleanup' \
      ppa_rst    'Purge PPAs' \
      3>&1 1>&2 2>&3)

  __menu_info_add_repo="
  Settings for additional repositories is set as follows.
  -------------------------------------------------------
  Google Chrome & Google Earth : $add_google_repo
  Google Cloud SDK             : $add_gcp_repo
  GCS-Fuse                     : $add_gcsfuse_repo
  Visual Studio Code           : $add_vscode_repo
  Docker Community Edition     : $add_docker_repo
  Insync                       : $add_insync_repo
  Skype for Linux              : $add_skype_repo
  Signal for Desktop           : $add_signal_repo
  Mendeley                     : $add_mendeley_repo
  ROS (Robot Operating System) : $add_ros_repo
  Duo Security for Unix        : $add_duo_repo
  GitHub CLI (gh)              : $add_gh_repo
  Gvisor container runtime     : $add_gvisor_repo
  Hashicorp Packages           : $add_hashicorp_repo

  Proceed with this action?
  "

  __menu_info_upgrade="
  This action will upgrage already installed packages on your system.

  Please pin package versions to avoid them from being automatically
  updated.
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_update="
  This action will update repository metadata. This action
  will simple run apt-get update as root.
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_ppa="
  This action will add PPAs from the config to your system.
  Some dependency packages like curl and software-properties
  might get installed to enable adding these PPAs.
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_apps="
  This action will install packages defined in your config.
  As there might be hundreds of packages they are not displayed
  here. Please ensure that packages are valid and are available
  on your distribution. This might take some time depending on
  your Internet connection and CPU.
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_repo_rst="
  This action can remove PPAs and repositories added by
  this script. Please do note that any changes
  not made my this script might be ignored.
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_ppa_rst="
  This action can remove PPAs  added by this script.
  Please do note that any changes not made my this script
  might be ignored. This task will install ppa-purge and
  will revert packages provided by the ppas to the ones
  provided by distriution. Use this with caution!
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_purge="
  This action can remove packages which come
  preinstalled on Ubuntu/Debian installation.
  Use this with caution! Removing a core dependency might
  lead t a broken system!
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_all="
  This will run ALL the tasks except
  deleting logs, purging PPAs and removing repos.

  Order of execution is as follows.

  - Update repository metadata
  - Upgrade packages
  - Add Repositories
  - Add PPAs
  - Install Packages
  - Install DEB files
  - Install Python 2 modules (if supported)
  - Install Python 3 Modules
  - Install Static binaries
  - Install Snap Packages
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_debs="
  This will download and install debian packages mentioned in
  the config file. Please note that this is slightly less secure,
  as GPG signature verification is not done on the packages
  downloaded.
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_pip3="
  This will download and install PIP3 packages. PIP packages will be
  installed as system site packages. Its recommened NOT to use this
  feature except for core system management packages. Either use packages
  provided by system's package manager (It is easier to update them)
  or use virtualenv or per user packages.
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_pip2="
  This will download and install PIP2 packages. PIP packages will be
  installed as system site packages. Its recommened NOT to use this
  feature except for core system management packages. Either use packages
  provided by system's package manager (It is easier to update them)
  or use virtualenv or per user packages.

  ::WARNING::
  Python 2 may not be supported on recent distributions!
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_snaps="
  Install snap packages. If your system did not come preinstalled with
  snapd, it will be installed. If you are running a DNS server on the
  machine, lxd's dnsmasq might cause port conflicts.

  You must specify snaps under correct category.
  - classic (no confinement)
  - normal (default snap confinement)
  - edge (beta versions and some unconfined packages)

  ::WARNING::
  This task will fail inside docker containers!
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_bin="
  Install static binaries. This task will download and put
  your binaries in /usr/local/bin. Please ensure to use correct
  binaries for your system and ensure that
  /usr/local/bin is in your PATH.
  -------------------------------------------------------

  Proceed with this action?
  "

  whiptail_exitstatus=$?
  _log_debug "Whiptail Exit status is : $whiptail_exitstatus"
  if [ $whiptail_exitstatus = 0 ]; then
      _log_debug "Whiptail Task is: $task"
      case $task in
      update)     _prompt_confirmation "$__menu_info_update" "update_repos_as_task"
                  ;;
      upgrade)    _prompt_confirmation "${__menu_info_upgrade}" "upgrade_apps"
                  ;;
      ppas)       _prompt_confirmation "${__menu_info_ppa}" "add_ppas"
                  ;;
      repo)       _prompt_confirmation "$__menu_info_add_repo" "add_repositories"
                  ;;
      apps)       _prompt_confirmation "$__menu_info_apps" "install_apps"
                  ;;
      repo_rst)   _prompt_confirmation "${__menu_info_repo_rst}" "disable_external_repos"
                  ;;
      ppa_rst)    _prompt_confirmation "${__menu_info_ppa_rst}" "purge_ppa"
                  ;;
      purge)      _prompt_confirmation "${__menu_info_purge}" "purge_not_required"
                  ;;
      all)        _prompt_confirmation "${__menu_info_all}" "all_in_one"
                  ;;
      debs)       _prompt_confirmation "${__menu_info_debs}" "install_debs"
                  ;;
      pip2)       _prompt_confirmation "${__menu_info_pip2}" "install_pip_packages_2"
                  ;;
      pip3)       _prompt_confirmation "${__menu_info_pip3}" "install_pip_packages_3"
                  ;;
      bin)        _prompt_confirmation "${__menu_info_bin}" "install_binaries"
                  ;;
      snaps)      _prompt_confirmation "${__menu_info_snaps}" "install_snaps"
                  ;;
    esac
  else
    _log_debug "Whiptail Exit code : $whiptail_exitstatus"
    _log_debug "Exiting because user selected Quit or Whiptail has non zero exit code."
  fi
}


function _ci_cloud_and_container_checks()
{

  if [ "$bool_skip_env_checks" == "true" ]; then
    _log_debug "Skipping Run environment checks"
  else
    _log_stage "Running environment checks..."
    # Check if running in CI & Containers
    # VMs, GCP, AWS, Docker.
    #================================ CI =============================================
    if [ "$TRAVIS" == "true" ]; then
      _log_dev "Running on Travis CI"
    elif [ "$APPVEYOR" == "true" ]; then
      _log_dev "Running on Appveyor CI"
    elif [ "$TF_BUILD" == "True" ]; then
      _log_dev "Running on Azure Pipelines"
    elif [ "$GITHUB_ACTIONS" == "true" ]; then
      _log_dev "Running on GitHub Actions"
    fi

    # Internal checks
    if [ "$AE_INTERNAL_CI_MODE" == "true" ]; then
      _log_dev "Enforcing CI MODE"
      _log_dev "This is to be used only while testing the script."
      _log_dev "This will ignore --simulate flag in some cases!!"
    fi

    if grep -q Microsoft /proc/version; then
      _log_warn "Running on Windows Subsystem for Linux"
    fi
    #============================ Docker =============================================
    if grep docker /proc/1/cgroup -qa; then
      _log_dev "Running in docker"
    else
      _log_debug "Probably not running in docker"
    fi
    #------------------------------- EC2, GCP, DO ------------------------------------
    # This first, simple check will work for many older instance types.
    if [ -f /sys/hypervisor/uuid ] && [ "$(head -c 3 /sys/hypervisor/uuid)" == "ec2" ]; then
      _log_dev "Running on EC2"

    # This check will work on newer m5/c5 instances, but only if you have root!
    # If the file exists AND is readable by us, we can rely on it.
    elif [ -r /sys/devices/virtual/dmi/id/product_uuid ] && [ "$(head -c 3 /sys/devices/virtual/dmi/id/product_uuid)" == "EC2" ]; then
      _log_dev "Running on EC2"

    # Fallback check of http://169.254.169.254/. If we wanted to be REALLY
    # authoritative, we could follow Amazon's suggestions for cryptographically
    # https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html
    # but this is almost certainly overkill for this purpose (and the above
    # checks of "EC2" prefixes have a higher false positive potential anyway).
    elif wget -O- -q --timeout=1 --tries=1 http://169.254.169.254/latest/dynamic/instance-identity/document | grep -q availabilityZone; then
      _log_dev "Running on EC2"

    #------------------------------- GCP ---------------------------------------------
    elif wget -q -O- --timeout=1 --tries=1 -nc --header="Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/virtual-clock/drift-token > /dev/null; then
      _log_dev "Running on Google Compute"

    elif wget -q -O- --timeout=1 --tries=1 -nc  http://169.254.169.254/metadata/v1/id; then
      _log_dev "Running on Digital Ocean droplet"

    elif AZURE_REGION="$(wget -q -O- --timeout=1 --tries=1 --header "Metadata:true" "${AZURE_METADATA_URL}")"; then
      _log_dev "Running on Microsoft Azure ${AZURE_REGION}"

    else
      _log_debug "Probably not running on AWS/GCP/Azure or Digital Ocean."
    fi

  fi

}

function display_version()
{
  printf "%-15s : %s\n" "Version Number" "${REL_NUM}"
  printf "%-15s : %s\n" "Version Name" "${REL_NAME}"
  printf "%-15s : %s\n" "Executable" "${SCRIPT}"
}


function display_usage()
{
#Prints out help menu
cat <<EOF
A Post Installation Script for Ubuntu, Debian,
Linux Mint, elementary OS, Pop!_OS, MX Linux etc.${NC}
Usage: ${TEAL} [sudo] ./${SCRIPT} ${ORANGE}  [options]${NC}
${YELLOW}
Non-Action options (can be run as non-root user)
-----------------------------------------------------------${NC}
[-v | --version]      Display version info.
[-h | --help]         Display this help message.
${YELLOW}
Configuration Options
---------------------------------------------------------${NC}
[-c | --config-file]  Local yaml config file.
[-R | --remote-yaml]  Use config yaml from a URL.
${LIGHT_BLUE}
The following options are "action" options and
will make changes to your system depending on tasks chosen.
---------------------------------------------------------${NC}
[-d | --purge]        Enable Purging packages
[-f | --fix]          Fix codenames for new releases
[-p | --pre-release]  Same as --fix but for beta/alpha
                      releases of Ubuntu and Debian.
[--fix-mode-lts]      Similar to --fix but fallback to
                      last LTS. Should be used with --fix.
                      Only works on Ubuntu and Debian.
[-k | --keep-debs]    Do not invoke apt-clean & do not
                      delete downloaded deb packages.
[-l | --delete-log]   Delete logfile. (log/after-effects.log)
[-s | --simulate]     Try not to make changes to system
                      and use --dry-run Please read the
                      documentation, to know its limits
                      as everything cannot be simulated.
${YELLOW}
Other Options
---------------------------------------------------------${NC}
[--no-env-checks]     Skip some env checks.
[--no-version-check]  Skip checking for latest version
[-A | --autopilot]    Enables AUTOPILOT mode(No Prompts).
${GRAY}
Debugging Options
---------------------------------------------------------
[-nx | --nx]          Just process config but do not
                      make any changes to the system.
[--debug]             Prints debug logs.
[--debug-trace]       Prints trace level logs which includes
                      output from apt-get and other commands.
${TEAL}
Documentation, License and Version Information
---------------------------------------------------------${NC}
Version : ${ORANGE}${REL_NAME}${NC}
GitHub  : ${LIGHT_BLUE}https://git.io/Jv08V${NC}
Docs    : ${LIGHT_BLUE}https://ae.prasadt.com${NC}
License : ${ORANGE}GPLv3${NC}
---------------------------------------------------------${NC}
EOF
}

function _process_non_root_options()
{
  # Process command line arguments which does not require root.
  if [[  $# -eq 0 ]]; then
    printf "${RED}✕ No arguments specified! See Usage Below${NC}\n"
    display_usage
    exit 1
  elif [[  $# -eq 1 ]]; then
    while [ "${1}" != "" ]; do
      case ${1} in
        -v | --version)     display_version;
                            exit 0;
                            ;;
        -G | --verify)      verify_gpg_signature;
                            exit 0;
                            ;;
        -l | --delete-log)  delete_log_file;
                            ;;
        -h | --help)        display_usage;
                            exit 0;
                            ;;
        *)                  printf "${RED}✕ This does not appear to be a valid option${NC}\n";
                            printf "${RED}✕ Non action options take more than one argument!${NC}\n";
                            exit 1;
                            ;;
      esac
      shift
    done
  fi
}


function process_no_exec_option()
{
  while [ "${1}" != "" ]; do
    case ${1} in
      -n | --nx)      readonly AE_INTERNAL_NO_EXECUTE="true";;
    esac
    shift
  done
}

function main()
{
  _init_printf_variables

  # Display Version Info and Verify signature options
  _process_non_root_options "$@"

  printf "${TEAL}• Initialize & run checks${NC}\n"
  process_no_exec_option "$@"

  printf "  • Permission checks\n"

  if [[ $AE_INTERNAL_NO_EXECUTE == "true" ]]; then
    # Actual logging starts
    _init_logging
    _log_dev "Running in NX mode"
  elif [[ $EUID -ne 0 ]]; then
    printf "${RED}✕ Insufficient privileges!!${NC}\n"
    printf "${RED}✕ This script must be run as root.\n"
    printf "${RED}✕ Please use sudo ${dir}/$SCRIPT to run this as root.\n"
    exit 2;
  else
    # We were not running in NX mode, and we are root.
    _init_logging
    _log_success "Running as root"
  fi

  # Init vars
  _init_script_variables;

  # Process command line arguments.
  while [ "${1}" != "" ]; do
    case ${1} in
      -s | --simulate)        readonly simulate_apt_install="true";
                              _log_property "Simulate" "ENABLED" "2";
                              ;;
      -f | --fix)             bool_fix_repo_not_available_for_latest="true";
                              _log_property "Fix" "ENABLED" "2";
                              ;;
      --fix-mode-lts)         bool_fix_repo_lts="true";
                              _log_property "FIX MODE" "LTS" "2";
                              ;;
      -p | --pre-release)     bool_fix_repo_not_available_for_upcoming_release="true";
                              _log_property "FIX MODE" "PRE-RELEASE" "2";
                              ;;
      -d | --purge)           bool_purge_pkgs="true";
                              _log_notice "Purge packages is set to true."
                              _log_warn "No checks are being made on the packages in the list."
                              _log_warn "Use carefully!. Purging system packages is a stupid idea!"
                              ;;
      -y | --yes)             _log_warn "-y | --yes is no longer available, Use Autopilot instead";
                              ;;
      -k | --keep-debs)       bool_preserve_debs="true";
                              _log_notice "Will keep downloaded DEB packages."
                              ;;
      -V | --no-version-check) bool_check_version="false";
                              ;;
      -r | --remote-yaml)     _log_warn "Using Remote YAML config!";
                              _log_warn "Use only from trusted remote sources!"
                              readonly bool_remote_yaml="true";
                              shift;
                              readonly url_remote_yaml="${1}";
                              ;;
      -c | --config-file | --config)  shift;
                              readonly local_config_file="${1}";
                              readonly bool_local_config="true";
                              _log_property "Config file" "LOCAL" 2
                              ;;
      -H | --hide-config)     _log_warn "-H/--hide-config is no longer supported."
                              _log_and_exit "Use --debug or --debug-trace" "26"
                              ;;
      -A | --autopilot)       _log_property "Autopilot" "ENABLED" "2";
                              readonly AE_AUTOPILOT="true";
                              ;;
      --use-uf-mirror)        _log_warn "Will use Uni-Freiburg mirror(s) if available";
                              readonly bool_use_uf_mirror="true";
                              ;;
      -E | --skip-env-checks) readonly bool_skip_env_checks="true";;
      # Debug options
      --version-file)         shift;
                              readonly custom_v_file="${1}";
                              readonly bool_custom_v_file="true"
                              _log_dev "Using custom version yml file"
                              ;;
      --debug)                AE_DEBUG=1;;
      --debug-ci)             AE_DEBUG=2;;
      --debug-trace)          AE_DEBUG=3;;
      --debug-ci-mode)        readonly AE_INTERNAL_CI_MODE="true";;
      -n | --nx)              :;;
      # The following arguments should always be used as the only arguments.
      -l | --delete-logfile)  _log_and_exit "-l or --delete-logfile should be the only argument." "23";;
      -v | --version)         _log_and_exit "-v or --version should be the only argument." "23";;
      -G | --verify)          _log_and_exit "--verify should be the only argument." "23";;
      -h | --help)            _log_and_exit "-h or --help should be the only argument." "23";;
       *)                     _log_and_exit "Invalid option: $1" "22";;
    esac
    shift
  done


  # Initialize variables and checks
  local after_effects_core_dependencies=(wget whiptail ping ps grep cut tr awk)
  _check_dependencies "${after_effects_core_dependencies[@]}"

  _init_print_basic_info;

  # Did I tell you that I need to call My friends over internet?
  _test_internet_connection;

  _log_info "Checking if configuration"

  # Handle Remote YAML
  _log_var "bool_local_config"
  _log_var "local_config_file"
  _log_var "bool_remote_yaml"
  _log_var "url_remote_yaml"

  if [[ -z ${local_config_file} ]] && [[ -z ${url_remote_yaml} ]]; then
    _log_error "Undefined configuration!"
    _log_and_exit "Did you forget to pass --config-file/--remote-yaml option?" "63"

  fi

  if [ "$bool_local_config" == "true" ] && [ "$bool_remote_yaml" == "true" ]; then
    _log_and_exit "Cannot use local config (-c) with remote YAML (-R) Use one of them." "25"
  fi

  if [ "$bool_local_config" == "true" ] && [ ! -f "$local_config_file" ]; then
    _log_and_exit "Config file you have specified is not found or not accessible" "36"
  fi

  if [ "$bool_custom_v_file" == "true" ] && [ ! -f "$custom_v_file" ]; then
    _log_and_exit "Custom version info file you have specified is not found or not accessible" "36"
  fi

  _log_success "OK"



  # Checks CI & Containers If running on EC2/GCP/Azure/DO
  _ci_cloud_and_container_checks;

  # Take care of Mint and other distros
  _fix_ubuntu_derivatives;

  # Get Remote Config File/s, check version & configure
  _log_var "bool_custom_v_file"
  _log_var "custom_v_file"
  _version_checks;

  _set_yaml_config;

  _log_stage "Check if terminal is non interactive"
  if [[ ! -t 1 ]] && [[ $AE_AUTOPILOT != "true" ]]; then
    _log_error "Terminal is not interactive, yet you have not specified --autopilot flag!"
    _log_and_exit "Non-interactive terminal requires --autopilot" "54"
  else
    _log_success "OK"
  fi

  # I don't like when someone else is occupying my room
  # Test if any apt-get ops are running
  _log_stage "Check for conflicting apps"
  _test_conflicting_apps;

  if [[ $AE_INTERNAL_NO_EXECUTE == "true" ]]; then
    _log_dev "Will not execute any tasks!"
    _script_exit_log;
    exit 255
  fi

  # Autopilot
  _log_stage "Checking for Autopilot"
  if [[ ${AE_AUTOPILOT} == "true" ]]; then
    bool_say_yes_to_all="true"
    _log_success "Autopilot is ENABLED"
    sleep 3;
    #_log_and_exit "Because I can" "255"
    _autopilot_check_task_flag_and_run "$ae_task_update" "update_repos_as_task"
    _autopilot_check_task_flag_and_run "$ae_task_upgrade" "upgrade_apps"
    _autopilot_check_task_flag_and_run "$ae_task_repo" "add_repositories"
    _autopilot_check_task_flag_and_run "$ae_task_ppa" "add_ppas"
    _autopilot_check_task_flag_and_run "$ae_task_apt" "install_apps"
    _autopilot_check_task_flag_and_run "$ae_task_debs" "install_debs"
    _autopilot_check_task_flag_and_run "$ae_task_pip2" "install_pip_packages_2"
    _autopilot_check_task_flag_and_run "$ae_task_pip3" "install_pip_packages_3"
    _autopilot_check_task_flag_and_run "$ae_task_purge" "purge_not_required"
    _autopilot_check_task_flag_and_run "$ae_task_bin" "install_binaries"
    _autopilot_check_task_flag_and_run "$ae_task_snaps" "install_snaps"
  else
    sleep 2
    _log_notice "Autopilot is Inactive"
    _process_menu;
  fi

  _script_exit_log;
}

#Run Main
main "$@"
