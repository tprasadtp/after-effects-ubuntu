#!/usr/bin/env bash
# shellcheck disable=SC2059
# vim: filetype=sh

# Author: Prasad Tengse
# Licence: GPLv3
# Github Repository: https://github.com/tprasadtp/ubuntu-post-install
# Requirements - Bash v4 and above
#              - whiptail, wget, iputils-ping, awk, sed, grep
#

readonly AE_EXEC_START=$(date +%s)
readonly SCRIPT=$(basename "$0")

case "${DEBUG}" in
  1 | "yes" | "true" | "TRUE")     AE_DEBUG=1;set -o pipefail;;
  "internal")                      AE_DEBUG=2;set -o pipefail;;
  "ci" | "CI")                     AE_DEBUG=2;set -eo pipefail;;
  "trace")                         AE_DEBUG=3;set -o pipefail;;
  *)                               AE_DEBUG=0;set -o pipefail;;
esac

# SCRIPT METADATA
readonly dir=$(cd -P -- "$(dirname -- "$0")" && pwd -P)
readonly REL_NAME="6.0.0 Alpha"
readonly REL_NUM=600

# YQ Version to use
readonly YQ_VERSION="3.3.0"

function _init_printf_variables()
{
  #Initialize printf variables

    #================ Because I care about Beauty of Output Logs =================
    readonly           _repo="[    Add-Repo   ]"
    readonly            _ppa="[      PPA      ]"
    readonly          _oh_no="[     Oh No!    ]"
    readonly     _installing="[   Installing  ]"
    readonly      _installed="[   Installed   ]"
    readonly        _removed="[    Removed    ]"
    readonly       _deleting="[    Deleting   ]"
    readonly      _linuxmint="[  Linux - Mint ]"
    readonly     _elementary="[ Elementary-OS ]"
    readonly          _purge="[     Purge     ]"
    readonly          _error="[     Error!    ]"
    readonly         _update="[     Update    ]"
    readonly        _upgrade="[    Upgrade    ]"
    readonly    _derivatives="[  Derivatives  ]"
    readonly      _conflicts="[   Conflicts   ]"
    readonly         _notice="[    Notice     ]"
    readonly            _deb="[   Debian-PKG  ]"
    readonly           _info="[     Info      ]"
    readonly       _simulate="[   Simulating  ]"
    readonly       _fix_repo="[      Fix      ]"
    readonly           _warn="[    Warning    ]"
    readonly         _whoops="[     Oops!     ]"
    readonly    _pre_release="[  Pre Release  ]"
    # readonly    _new_release="[  New Release  ]"
    readonly        _version="[    Version    ]"
    readonly       _checking="[    Checking   ]"
    readonly            _eol="[      EOL      ]"
    readonly        _running="[    Running    ]"
    readonly      _autopilot="[   Autopilot   ]"
    readonly            _api="[      API      ]"
    readonly          _debug="[     DEBUG     ]"
    readonly       _internal="[    INTERNAL   ]"
    readonly          _trace="[      TRACE    ]"
    readonly       _ppa_logs="[    PPA-Logs   ]"
    readonly       _apt_logs="[    APT-Logs   ]"
    readonly      _dpkg_logs="[    PKG-Logs   ]"
    readonly   _apt_key_logs="[  APT-Key-Logs ]"
    readonly       _pip_logs="[    PIP-Logs   ]"
    readonly            _cfg="[     Config    ]"
    readonly         _rtasks="[     Tasks     ]"
    readonly             _ci="[      C-I      ]"
    readonly          _table="[  ---Table---  ]"
    readonly          _array="[   PKG Array   ]"
    readonly            _apt="[  APT-Packges  ]"
    readonly           _snap="[    Snap PKG   ]"
    readonly        _success="[    Success    ]"
    readonly       _dev_mode="[    DEV-MODE   ]"

    #colors for display
    readonly YELLOW=$'\e[33m'
    readonly GREEN=$'\e[32m'
    readonly BOLD_GREEN=$'\e[1;32m'
    readonly ORANGE=$'\e[38;5;209m'
    readonly RED=$'\e[31m'
    readonly BLUE=$'\e[34m'
    readonly NC=$'\e[0m'
    readonly MAGENTA=$'\e[35m'
    readonly GRAY=$'\e[38;5;247m'
    readonly LOG_GRAY=$'\e[38;5;241m'
    readonly INTERNAL_GRAY=$'\e[38;5;244m'


    # Generate a UUID
    readonly CLIENT_ID=$(cat /proc/sys/kernel/random/uuid)

}


function _init_logging()
{
  # Initialize phase 2
  # Only variables necessary for logging & start logging
  # Script related variables are defined in _init_script_variables
  readonly log_file="$dir"/logs/after-effects.log
  {
    mkdir -p "$dir"/logs
  } ||
  {
    printf "${RED}${_error} Failed to create logs folder${NC}\n"; exit 2
  }
  # tmp dir
  {
    rm -rf /tmp/ae/*
    mkdir -p /tmp/ae/
  } ||
  {
    printf "${RED}${_error} Failed to create tmp folder${NC}\n"; exit 2
  }

  # if file not exists touch it
  if [[ ! -f ${log_file} ]]; then
    if touch "${log_file}"; then
      printf "${GRAY}${_debug} Created Log file${NC}\n"
    else
      printf "${GRAY}${_debug} Failed to create logfile!${NC}\n"
      exit 2
    fi
  fi

  # check if logs can be written
  if [[ -w $log_file ]]; then
    {
      _log_debug "Initialize logging for RUN ID: ${CLIENT_ID}"
    } ||
    {
      printf "${RED}${_error} Failed to write to log file ${log_file} ${NC}\n"; exit 2
    }
  else
    printf "${RED}${_error} Log File is not writable!${NC}\n"
    exit 2
  fi
}


# Utility Functions
function _line_fill()
{
   if [[ ! -t 1 ]]; then
    printf "_______________________________________________________\n"
  else
    printf "%-$(tput cols)s@%s\n" | sed -e "s/ /-/g" -e "s/-@/ /" -e "s/@-/ /"
  fi
}


function set_blue()
{
  printf "${BLUE}"
}


function set_yellow()
{
  printf "${YELLOW}"
}

function set_green()
{
  printf "${GREEN}"
}

function set_orange()
{
  printf "${ORANGE}"
}


function set_magenta()
{
  printf "${MAGENTA}"
}


function set_red()
{
  printf "${RED}"
}


function set_log_gray()
{
  printf "${LOG_GRAY}"
}

function set_default()
{
  printf "${NC}"
}


function _goodbye_msg ()
{
  printf "\nâœ°  ${ORANGE}Show your support by starring this repo on GitHub.${NC}"
  printf "\nðŸ”— ${BOLD_GREEN}Link ${NC}- ${BLUE}https://git.io/Jv08V${MAGENTA}"
  printf "\nâŸ¿  Have a great time with this Linux Machine.${NC}\n"
}


function _log_and_exit()
{
  # ARG-1 log msg
  # ARG-2 exit code int
  local msg="$1"
  printf "${RED}$msg${NC}\n";
  {
    printf "[$(date)] ${msg}\n" >> "$log_file";
    printf "\nFinished ${SCRIPT} on $(date).\nExit code: $(date)\n"
  } >> "$log_file"
  _line_fill
  _line_fill >> "$log_file"
  exit "$2";
}


function _script_exit_log()
{
    # Script time
    readonly AE_EXEC_END=$(date +%s)
    readonly AE_EXEC_TIME=$(( AE_EXEC_END - AE_EXEC_START ))

    # Generate Exit message & log
    _goodbye_msg
    _log_debug "Exiting Script"
    _log_debug "Finished $SCRIPT in $EXEC_TIME seconds, on %s.\n"
    _line_fill >> "$log_file"
    return 0
}

function _log_and_show()
{
  local msg="$1"
  printf "$msg\n"
  printf "[$(date)] $msg\n" >> "$log_file"
}


function _log_debug()
{
  local msg="$1"
  if [[ ${AE_DEBUG} -gt 0 ]]; then
    printf "${GRAY}${_debug} $msg${NC}\n"
  fi
  printf "[$(date)] ${_debug} $msg\n" >> "$log_file"
}


function _log_success()
{
  local msg="$1"
  printf "${GREEN}$msg ${NC}\n"
  printf "[$(date)] $msg\n" >> "$log_file"
}

function _log_warn()
{
  local msg="$1"
  printf "${YELLOW}$msg ${NC}\n"
  printf "[$(date)] $msg\n" >> "$log_file"
}

function _log_dev()
{
  local msg="$1"
  printf "${ORANGE}${_dev_mode} $msg ${NC}\n"
  printf "[$(date)] ${_dev_mode} $msg\n" >> "$log_file"
}

function _log_internal()
{
  local msg="$1"
  if [[ $AE_DEBUG -gt 1 ]]; then
    printf "${INTERNAL_GRAY}${_internal} $msg ${NC}\n"
  fi
  printf "[$(date)]${_internal} $msg\n" >> "$log_file"
}

function _log_trace()
{
  local msg="$1"
  if [[ $AE_DEBUG -gt 2 ]]; then
    printf "${LOG_GRAY}${_trace} $msg ${NC}\n"
  fi
  printf "[$(date)] $msg\n" >> "$log_file"
}

function _log_notice()
{
  local msg="$1"
  printf "${BLUE}$msg ${NC}\n"
  printf "[$(date)] $msg\n" >> "$log_file"
}

function _log_error()
{
  local msg="$1"
  printf "${RED}$msg ${NC}\n"
  printf "[$(date)] $msg\n" >> "$log_file"
}

function _log_info()
{
  local msg="$1"
  printf "$msg ${NC}\n"
  printf "[$(date)] $msg\n" >> "$log_file"
}

#shellcheck disable=SC2120
function detect_distribution()
{
  # Read /etc/os-release and get
  local OS_RELEASE_FILE

  OS_RELEASE_FILE="${1:-/etc/os-release}"
  if [[ -r "${OS_RELEASE_FILE}" ]]; then
    _log_debug "Found os-release file ${OS_RELEASE_FILE}, attemping to read it."
    # Read Version Code Name
    readonly AE_DISTRO_CODENAME="$(awk '/VERSION_CODENAME=/' "${OS_RELEASE_FILE}" | sed 's/VERSION_CODENAME=//' | tr '[:upper:]' '[:lower:]')"

    # Read Human Readable Full Version Name
    readonly AE_DISTRO_PRETTY_NAME="$(awk '/PRETTY_NAME=/' "${OS_RELEASE_FILE}" | sed 's/PRETTY_NAME=//' | tr -d '"')"

    # Read Human Readable Distro Name
    readonly AE_DISTRO_NAME="$(awk '/^NAME=/' "${OS_RELEASE_FILE}" | sed 's/^NAME=//' | tr -d '"')"
  else
    _log_error "${_error} Hey, What are you running this script on?"
    _log_and_exit "${_error} I cannot determine distro/codename!" "5"
  fi
}


function _init_script_variables()
{
  # Function defines Script variables
  # Necessary variables used by the script are initialized here. This function
  # should be called first before choices are made, always.

  #shellcheck disable=SC2119
  detect_distribution

  # Achtung: Do not set code_name as readonly!!
  code_name="${AE_DISTRO_CODENAME}"
  readonly architecture="$(dpkg --print-architecture)"
  case "${architecture}" in
    amd64)          _log_debug "Architecture is 64 bit.";
                    readonly ARCH="amd64";
                    readonly YQ_BIN_ARCH="amd64";
                    ;;
    i386)           _log_debug "Architecture is 32 bit.";
                    _log_and_exit "i386 is no longer Supported!" "11"
                    ;;
    armhf)          _log_debug "Running on ARM CPU with HW Floating point Processor";
                    readonly ARCH="armhf";
                    readonly YQ_BIN_ARCH="arm";
                    ;;
    arm64)           _log_debug "This is an ARM 64. Please be advised that not all repositories support this arch.";
                    readonly ARCH="arm64";
                    readonly YQ_BIN_ARCH="arm";
                    ;;
    * )             _log_error "${_error} Sorry! This architecture is not supported by this script!"
                    _log_and_exit "Unsupported Architecture. $(architecture)" "11"
                    ;;
  esac

  # Get Hostname
  readonly CLIENT_NAME=$(hostname)

  # etc sources list dir
  readonly SOURCES_FILE_DIR=/etc/apt/sources.list.d

  # Ping URL
  readonly PING_URL="www.google.com"


  #-------------------------- Release codenames --------------------------------------
  readonly code_name_latest_release="focal"
  readonly codename_previous_release="eoan"
  readonly codename_upcoming_release="groovy"
  readonly codename_lts_fallback="focal"
  readonly code_name_latest_debian_release="buster"
  readonly codename_upcoming_debian_release="bullseye"

  #============================ Switches/ booleans & Vars ================================


  # Fix Repo not available for latest release
  bool_fix_repo_not_available_for_latest="false"


  # Allow repo fixes for Upcoming releases of ubuntu and its derivatives.
  bool_fix_repo_not_available_for_upcoming_release="false"

  # Checks for Version
  # Define API node endpoints

  bool_check_version="true"

  readonly api_version_url="https://ae.prasadt.com/config/version.yml"


  # Achtung!!
  # ========================================================================================= #

  # Purge not required packages
  # Default is false
  # Requires command line option -d to be passed via command line otherwise it will not work.
  # Set this to true if you don't want to pass -d every time
  bool_purge_not_required_pkgs="false"

  # Say yes to all (No whiptail dialogs)
  # Default is false
  # Can be set to true and dialog boxes will be skipped if command line option -y is passed.
  # Set this to true if you don't want to pass -y every time
  bool_say_yes_to_all="false"

  # Keep Downloaded DEB packages
  bool_preserve_debs="false"

  #
  # ================================================================================== #
  # Achtung!
  # Do not change any of the variables below this if you don't know what they do.
  # They are essential for correct working of the script or use unstable builds/repos.

  # Check Debian Flags
  bool_is_debian="false"

  # Check Signature
  #readonly bool_verify_gpg_signatures="true"

  # Azure
  readonly AZURE_METADATA_URL="http://169.254.169.254/metadata/instance/compute/location?api-version=2017-08-01&format=text"

}


function _init_print_basic_info()
{
  # This function logs and displays the Necessary details which helps in debugging.
  # Should be used after _init_script_variables function.
  _log_notice "${_notice} Following details are recognized by the Script."
  _log_notice "${_info} Hostname: ${CLIENT_NAME}"
  _log_debug  "UUID for Run: ${CLIENT_ID}"
  _log_notice "${_info} OS: ${AE_DISTRO_PRETTY_NAME}"
  _log_notice "${_info} Distro: ${AE_DISTRO_NAME}"
  _log_notice "${_info} Code Name: ${AE_DISTRO_CODENAME}"
  _log_notice "${_info} Architecture: ${ARCH}"
  _log_debug  "Path for sources.list.d: ${SOURCES_FILE_DIR}"
  _log_success "${_version} ${REL_NAME} - ${REL_NUM}"

  #disable hist chars  so that I can print "!!"" properly
  histchars=
}


function delete_log_file()
{
  printf "${_deleting} log file...\n"
  if rm "${dir}/logs/after-effects.log"; then
    set_green
    printf "${GREEN}${_success} Deleted log file %s\n" "$log_file"
    set_default
    exit 0
  else
    set_red
    printf "${_error} Deleting log file failed. %s\n" "$log_file"
    exit 1;
  fi
}


function  _add_timestamp_to_logs()
{
  # This function adds time stamp to logs without using external utilities
  # Output will be automatically written to $log_file
  # Arguments : 1
  # ARG -1: printf variable for formatting the log
  # Usage command | _add_timestamp_to_logs "$1"
  while IFS= read -r line;
  do
    printf "[$(date)] ${1} %s\n" "$line" &>> "$log_file"
    if [[ $AE_DEBUG -gt 2 ]]; then
      printf "${LOG_GRAY}${1} %s${NC}\n" "$line"
    fi
  done

}


function _check_dependencies()
{
  #Checks if commands in array are available.
  # Accepts one argument as array.
  local dependencies=("$@")
  local dependency_check_failed_count dep_res dependency
  dependency_check_failed_count=0;
  _log_and_show "${_info} Checking dependencies..."
  for dependency in "${dependencies[@]}"; do
   command -v "$dependency" > /dev/null
   dep_res=$?
   if [ "$dep_res" -eq 1 ]; then
     _log_error "${_error} $dependency is not installed!${NC}"
     dependency_check_failed_count=$((dependency_check_failed_count+1))
   fi
  done

  if [ "$dependency_check_failed_count" -gt 0 ]; then
    _log_error "${_error} One or more dependencies not installed."
    _log_and_exit "${_error} Sorry! $SCRIPT cannot continue!" "1"
  fi
}


function __disp_sig_check_passed()
{
  # Displays message after --verify proves that the GPG signatures match
  set_green
  printf "OK! Signature verified!\n"
  set_default
}


function __disp_sig_check_failed()
{
  # Displays failed GPG signature message
  set_red;
  printf "Oh No! Signature checks failed.\n"
  printf "File is either corrupt or has been modified.\n"
  set_default;
}


function verify_gpg_signature()
{
  # Verifies the file with its detached GPG signature.
  # Assumes that you already have public key in your keyring.
  # Assumes signature file is present at same location,
  # with same name but with .sig or .gpg or .asc extension.
  local sig_file
  # Checks if file is present
  if [ -f "${SCRIPT}.sig" ]; then
    sig_file="${SCRIPT}.sig"
  elif [ -f "${SCRIPT}.asc" ]; then
    sig_file="${SCRIPT}.asc"
  elif [ -f "${SCRIPT}.gpg" ]; then
    sig_file="${SCRIPT}.gpg"
  else
    printf "${YELLOW}Error! Signature file not found.${NC}\n"
    exit 51;
  fi

  # Check for signature files
  printf "Verifying GPG signature of file..\n"
  printf "Signature File : ${sig_file}\n"
  printf "Data File      : $(basename $SCRIPT)\n"
  set_default
  # Checks for commands
  if command -v gpg > /dev/null; then
    if gpg --verify "${sig_file}" "${SCRIPT}" >/dev/null  2>&1; then
      __disp_sig_check_passed
    else
      __disp_sig_check_failed
      exit 50;
    fi
  elif command -v gpgv >/dev/null; then
    if gpgv --keyring "$HOME/.gnupg/pubring.kbx" "${sig_file}" "${SCRIPT}" > /dev/null  2>&1; then
      __disp_sig_check_passed
    else
      __disp_sig_check_failed
      exit 50;
    fi
  else
    printf "Cannot perform verification. gpgv or gpg is not installed."
    printf "This action requires gnugpg/gnupg2 or gpgv package.\n"
    exit 1;
  fi

}


function _eol_message()
{
  # Display EOL Message and upgrade instruction URLs.
  # Arguments: 1
  # ARG 1: EOL Date

  _log_error "${_eol} This version of ${AE_DISTRO_NAME} is no longer supported."
  _log_and_exit "${_eol} ${AE_DISTRO_PRETTY_NAME} reached EOL on $1." "12"
}


function _fix_ubuntu_derivatives()
{
  # Some Ubuntu based distributions use their own codename (Linux mint, Elementary)
  # Some repositories require that ubuntu codename is used.
  # This function fixes that for
  # Linux mint 17.X : Ubuntu 14.04 Trusty,
  # Linux mint 18.x : Ubuntu 16.04 Xenial,
  # Linux mint 19.x : Ubuntu 18.04 Xenial,
  # Elementary OS Loki : Ubuntu 14.04 Trusty,
  # Elementary OS Freya: Ubuntu 16.04 Xenial
  # Elementary OS Juno,Hera: Ubuntu 18.04 Xenial
  # Pop!_OS uses Ubuntu codenames (No need to apply fix)
  # KDE Neon, Bodhi, Peppermint use Ubuntu codenames
  # If the release is not known this function exits the script for safety.

  _log_and_show "${_derivatives} Checking..."
  _log_debug "Variable code_name is : $code_name"
  case ${code_name} in
      sarah | serena | sonya | sylvia )     _log_and_show "${_linuxmint} Release is Linux mint 18.X."
                                            _log_and_show "${_linuxmint} Setting additional repositories to follow Ubuntu 16.04."
                                            code_name="xenial";
                                            readonly distro_name="ubuntu";
                                            readonly enable_ppa="true";
                                            _log_success "${_linuxmint} Changed codename to $code_name"
                                            ;;
      tara | tessa | tina | tricia)         _log_and_show "${_linuxmint} Release is Linux mint 19.X."
                                            _log_and_show "${_linuxmint} Setting additional repositories to follow Ubuntu 18.04."
                                            code_name="bionic";
                                            readonly distro_name="ubuntu";
                                            readonly enable_ppa="true";
                                            _log_success "${_linuxmint} Changed codename to $code_name"
                                            ;;
      loki )                                _log_and_show "${_elementary} This release of Elementary OS is based on Ubuntu 16.04 Xenial."
                                            _log_and_show "${_elementary} External repositories will use Ubuntu 16.04."
                                            code_name="xenial";
                                            readonly distro_name="ubuntu";
                                            readonly enable_ppa="true";
                                            _log_success "${_elementary} Changed codename to $code_name"
                                            ;;
      juno | hera)                          _log_and_show "${_elementary} This release of Elementary OS is based on Ubuntu 18.04 Bionic."
                                            _log_and_show "${_elementary} External repositories will use Ubuntu 18.04."
                                            code_name="bionic";
                                            readonly distro_name="ubuntu";
                                            readonly enable_ppa="true";
                                            _log_success "${_elementary} Changed codename to $code_name"
                                            ;;
      xenial | bionic )                     readonly bool_config_partner_repo="true";
                                            readonly enable_ppa="true";
                                            readonly distro_name="ubuntu";
                                            _log_and_show "${_derivatives} This is a LTS release of Ubuntu"
                                            _log_success "${_derivatives} Keeping the codename as: $code_name."
                                            ;;
      focal )                               readonly bool_config_partner_repo="true";
                                            readonly python2_disabled="true";
                                            readonly enable_ppa="true";
                                            readonly distro_name="ubuntu";
                                            _log_and_show "${_derivatives} This is latest LTS release of Ubuntu"
                                            _log_success "${_derivatives} Keeping the codename as: $code_name."
                                            ;;
      ulyana)                               _log_and_show "${_linuxmint} Release is Linux mint 20.X."
                                            _log_and_show "${_linuxmint} Setting additional repositories to follow Ubuntu 20.04."
                                            code_name="focal";
                                            readonly python2_disabled="true";
                                            readonly distro_name="ubuntu";
                                            readonly enable_ppa="true";
                                            _log_success "${_linuxmint} Changed codename to $code_name"
                                            ;;
      eoan)                                 readonly bool_config_partner_repo="true";
                                            readonly enable_ppa="true";
                                            readonly distro_name="ubuntu";
                                            _log_and_show "${_derivatives} This is 19.10 eoan."
                                            if [[ $bool_fix_repo_not_available_for_latest != "true" ]] && [[ $bool_fix_lts != "true"  ]] ; then _log_notice "${_notice} If your repos are not yet supported, use --fix option"; fi
                                            _log_success "${_derivatives} Keeping the codename as: $code_name."
                                            ;;
      groovy )                              readonly bool_config_partner_repo="true";
                                            readonly enable_ppa="false";
                                            readonly distro_name="ubuntu";
                                            set_magenta;
                                            _log_and_show "${_pre_release} This is Ubuntu 20.10 Groovy"
                                            set_default
                                            _log_warn "${_warn} PPAs are disabled!"
                                            _log_warn "${_warn} This is pre-release version of Ubuntu, Use with caution!"
                                            ;;
      stretch | jessie | buster )           bool_is_debian="true";
                                            readonly distro_name="debian";
                                            readonly enable_ppa="false";
                                            _log_notice "${_derivatives} This is Debian. PPAs are disabled."
                                            ;;
      bullseye)                             bool_is_debian="true";
                                            readonly enable_ppa="false";
                                            readonly distro_name="debian";
                                            _log_warn "${_warn} You are running Debian Testing!"
                                            _log_warn "${_pre_release} This is pre release version of Debian. Use with caution!"
                                            _log_notice "${_notice} PPAs are disabled."
                                            ;;
      disco )                               _eol_message "January 23rd, 2020"
                                            ;;
      *)                                    _log_error "${_error} Unknown Distribution/Release."
                                            _log_notice "${_notice} This Script is not designed to run on this ($code_name) distro/release."
                                            _script_exit_log;
                                            exit 16;
                                            ;;
  esac
  set_default;

}


function _test_internet_connection ()
{
  # Function to check internet connection
  _log_and_show "${_checking} Internet connection..."
  if wget --tries=5 --timeout=2 "$PING_URL" -O /tmp/ae/testinternet &>/dev/null 2>&1; then
    rm -f /tmp/ae/testinternet
  else
    _log_error "${_oh_no} Booooooo! You are not connected to the Internet!. "
    _log_error "${_error} Please check your Internet connection and try again."
    rm -f /tmp/ae/testinternet || _log_debug "Failed to remove temp network connectivity resp file"
    _log_and_exit "${_error} No internet connection!" "14"
  fi
}


function _test_conflicting_apps ()
{
  # Function checks if any apps like syanptic aptitude are running.
  local lock
  _log_and_show "${_conflicts} Checking..."
  for lock in synaptic update-manager software-center apt-get dpkg aptitude
  do
    # shellcheck disable=SC2009
    if ps -U root -u root u | grep $lock | grep -v grep > /dev/null; then
      _log_and_exit "${_error} Installation won't work. Please close $lock first then try again." "15"
    else
      _log_debug "$lock is not running."
     fi
   done
   _log_success "${_conflicts} None detected."
}




function parse_yaml() {
  local yaml_file="${1}"
  local prefix="${2}"
  local s
  local w
  local fs

  s='[[:space:]]*'
  w='[a-zA-Z0-9_.-]*'
  fs="$(echo @|tr @ '\034')"

    (
        #shellcheck disable=SC1003
        sed -e '/- [^\"]'"[^\']"'.*: /s|\([ ]*\)- \([[:space:]]*\)|\1-\'$'\n''  \1\2|g' |

        sed -ne '/^--/s|--||g; s|\"|\\\"|g; s/[[:space:]]*$//g;' \
            -e "/#.*[\"\']/!s| #.*||g; /^#/s|#.*||g;" \
            -e "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
            -e "s|^\($s\)\($w\)${s}[:-]$s\(.*\)$s\$|\1$fs\2$fs\3|p" |

      awk -F"$fs" '{
          indent = length($1)/2;
          if (length($2) == 0) { conj[indent]="+";} else {conj[indent]="";}
          vname[indent] = $2;
          for (i in vname) {if (i > indent) {delete vname[i]}}
              if (length($3) > 0) {
                  vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("__")}
                  printf("%s%s%s%s=(\"%s\")\n", "'"$prefix"'",vn, $2, conj[indent-1],$3);
              }
          }' |

        sed -e 's/_=/+=/g' |

        awk 'BEGIN {
                FS="=";
                OFS="="
            }
            /(-|\.).*=/ {
                gsub("-|\\.", "_", $1)
            }
            { print }'
) < "$yaml_file"
}


function _get_remote_file()
{
  # Function to get remote file/response
  # exits script if it fails.
  # Accepts 2 arguments.
  # ARG 1: File name; Name of the local file the response or file should be saved as.
  # ARG 2: URL to the  file

  local file_name="${1}"
  local exit_status;
  local file_url="${2}"
  _log_debug "Remote file URL is set to ${file_url}"

  if [ "$#" -eq 2 ]; then
    # Remote files
    wget -q "${file_url}" -O "$file_name" >> $"$log_file"
    exit_status="$?"

    _log_debug "Exit code from wget is : $exit_status"
    if [[ $exit_status -eq 0 ]]; then
      _log_debug "Successfully retrieved file."
    else
      _log_warn "${_error} Something went wrong while retrieving ${file_name}."
      _log_and_exit "${_error} Error Getting file." "28"
    fi
  else
    _log_and_exit "${_error} Invalid number of arguments <_get_remote_file> Requires 2, got $#." "19"
  fi

}

function _verify_yq()
{
  local expected_shasum="${1}"
  local shasum

  __file_shasum="$(sha256sum "${dir}/yq")"

  _log_info "${_parser} Verifying..."
  _log_debug "Verifying checksums for ${dir}/yq"

  if echo "${shasum} ${dir}/yq" | sha256sum -c -; then
    _log_success "${_parser} checksums match!"
  else
    _log_internal "Got ${__file_shasum} instead of ${expected_shasum}"
    set_orange
    _log_info "${_report} Please report this error! https://git.io/Jv08"
    set_default
    _log_and_exit "${_parser} Error! Parser binary verification failed!" "62"
  fi

}

function __download_yq()
{
  _get_remote_file "yq" "${YQ_DOWNLOAD_URL}"
  _verify_yq "${YQ_CHECKSUM}"
}

function _version_checks ()
{
  # Checks if its running latest version.
  # Also suggest updating to latest version if current version is not latest,
  # Allows to deprecate old version as it can be suggested.
  # Check if Version Checks is enabled. (Default is enabled)
  if [ "$bool_check_version" == "true" ]; then
      _log_debug "Version Checks are enabled."
      _log_and_show "${_version} Checking for Updates..."
      if [ "$bool_custom_version_file" != "true" ]; then
        _log_debug "Using version config file."
        _log_debug "Deleting old Version YAMLS"
        rm -f "/tmp/ae/api-version.yml" || _log_debug "Deleting old version YAML failed."
        readonly version_yaml_file="/tmp/ae/api-version.yml"
        # Get response/file
        _get_remote_file "$version_yaml_file" "$api_version_url"
      else
        _log_and_show "${_cfg} Using local Version file : $custom_version_file"
        readonly version_yaml_file="$custom_version_file"
      fi

      # Parse YAML to variables
      _log_debug "Parsing Version Config File"
      eval "$(parse_yaml "$version_yaml_file")"
      # Assign them to local variables as sometimes bash if does not handle array elements very well.
      local api_rel_num="${version__number[0]}"

      # Assign Statistics reporting flag and endpoint to Global variables.
      # Debug Info
      _log_debug "Version from API: ${api_rel_num}"

      # If release number is higher than one in the script throw error & ask to update.
      if [[ $api_rel_num -gt $REL_NUM ]]; then
        _log_warn "${_version} A newer release is available.\n${_version} Please download latest release and try again."
        _log_warn "${_version} You are running version ${REL_NAME} with version number ${REL_NUM}."
        _log_and_show "${_version} Latest available version is ${version__name[0]}-${api_rel_num}."
        _log_and_exit "${_version} You can disable version checks by passing\n${_version} --no-version-checks" "24"
      elif [[ $api_rel_num -eq $REL_NUM ]]; then
        _log_success "${_version} All Good! You are running the latest version of script."
      elif [[ $api_rel_num -lt $REL_NUM ]]; then
        _log_notice "${_version} Hey Time traveler!\n${_version} You seem to be running a development version of script."
        _log_notice "${_version} You are running version ${REL_NAME} - ${REL_NUM}."
        _log_notice "${_version} Latest stable version is ${version__name[0]}-${api_rel_num}."
      fi

  # If version checks have been disabled
  else
    _log_warn "${_info} Version checks have been disabled."
  fi
  #sleep 5

}


function _check_bool()
{
  # Function to check if config has valid values for bool.
  # Accepted values are true and false
  # If invalid, defaults to false.
  # Accepts global var and bool to check as arguments
  local g_var param_bool default_val
  if [[ $# -eq 2 ]]; then
    default_val="false"
  else
    _log_and_exit "Internal error! bool validator takes only two arguments!" "19"
  fi

  g_var="${1}"
  param_bool="${2}"
  case "${param_bool}" in
    true | True | TRUE | Yes | yes | YES | 1 )  declare -g ${g_var}="true"
                                                _log_internal "$g_var is set to true"
                                                ;;
    false | False | FALSE | No | no | NO | 0 )  declare -g ${g_var}="false"
                                                _log_internal "$g_var is set to false"
                                                ;;
    *)                                          declare -g ${g_var}="${default_val}"
                                                _log_internal "$g_var will default to ${default_val}"
                                                ;;
  esac
}


function _set_yaml_config()
{

  # Get and parse the file
  _log_and_show "${_cfg} Processing..."
  if [ "$bool_custom_config_file" != "true" ]; then
    _log_and_show "${_cfg} Using Remote Config file."
    _log_debug "Deleting old YAMLS"
    rm -f "/tmp/ae/api-config.yml" || _log_debug "Deleting old version YAML failed."
    readonly config_yaml_file="/tmp/ae/api-config.yml"
    # Get response/file
    _get_remote_file "$config_yaml_file" "$api_config_url"
  else
    _log_and_show "${_cfg} Using local config file : $custom_config_file"
    readonly config_yaml_file="$custom_config_file"
  fi

  # Parse YAML to variables
  _log_debug "Parsing Config File "
  eval "$(parse_yaml "$config_yaml_file")"


  set_default;
  # Repo flags
  #################################################################################
  _check_bool "add_docker_repo" "${config__add_repo__docker[0]}"
  #add_docker_repo="${config__add_repo__docker[0]}"

  _check_bool "add_winehq_repo" "${config__add_repo__winehq[0]}"
  #add_winehq_repo="${config__add_repo__winehq[0]}"

  _check_bool "add_mendeley_repo" "${config__add_repo__mendeley[0]}"
  #add_mendeley_repo="${config__add_repo__mendeley[0]}"

  _check_bool "add_googlecloud_repo" "${config__add_repo__googlecloud[0]}"
  #add_googlecloud_repo="${config__add_repo__googlecloud[0]}"
  _check_bool "add_gcsfuse_repo" "${config__add_repo__gcsfuse[0]}"

  _check_bool "add_spotify_repo" "${config__add_repo__spotify[0]}"
  #add_spotify_repo="${config__add_repo__spotify[0]}"

  _check_bool "add_skype_repo" "${config__add_repo__skype[0]}"
  #add_skype_repo="${config__add_repo__skype[0]}"

  _check_bool "add_vscode_repo" "${config__add_repo__vscode[0]}"
  #add_vscode_repo="${config__add_repo__vscode[0]}"

  _check_bool "add_insync_repo" "${config__add_repo__insync[0]}"
  #add_insync_repo="${config__add_repo__insync[0]}"

  _check_bool "add_signal_repo" "${config__add_repo__signal[0]}"
  #add_signal_repo="${config__add_repo__signal[0]}"

  _check_bool "add_google_repo" "${config__add_repo__google[0]}"
  #add_google_repo="${config__add_repo__google[0]}"

  # ROS
  _check_bool "add_ros_repo" "${config__add_repo__ros[0]}"

  # DUO
  _check_bool "add_duo_repo" "${config__add_repo__duo[0]}"

  # Other Script Flags
  #################################################################################

  # Purge Packages
  _check_bool "bool_purge_not_required_pkgs" "${config__flags__purge_enabled[0]}"
  #bool_purge_not_required_pkgs="${config__flags__purge_enabled[0]}"

  # Keep Debs
  _check_bool "bool_preserve_debs" "${config__flags__preserve_debs[0]}"
  #bool_preserve_debs="${config__flags__preserve_debs[0]}"

  # Uni-Mirror
  _check_bool "bool_use_uni_freiburg_mirror" "${config__flags__uni_freiburg_mirror[0]}"

  # Tasks Flags
  ##################################################################################

  #ae_task_update="${config__tasks__update[0]}"
  _check_bool "ae_task_update" "${config__tasks__update[0]}"

  #ae_task_upgrade="${config__tasks__upgrade[0]}"
  _check_bool "ae_task_upgrade" "${config__tasks__upgrade[0]}"

  #ae_task_repo="${config__tasks__repo[0]}"
  _check_bool "ae_task_repo" "${config__tasks__repo[0]}"

  #ae_task_ppa="${config__tasks__ppa[0]}"
  _check_bool "ae_task_ppa" "${config__tasks__ppa[0]}"

  #ae_task_apt="${config__tasks__apt[0]}"
  _check_bool "ae_task_apt" "${config__tasks__apt[0]}"

  #ae_task_debs="${config__tasks__debs[0]}"
  _check_bool "ae_task_debs" "${config__tasks__debs[0]}"

  #ae_task_purge="${config__tasks__purge[0]}"
  _check_bool "ae_task_purge" "${config__tasks__purge[0]}"

  #ae_task_pip2="${config__tasks__pip2[0]}"
  _check_bool "ae_task_pip2" "${config__tasks__pip2[0]}"

  #ae_task_pip3="${config__tasks__pip3[0]}"
  _check_bool "ae_task_pip3" "${config__tasks__pip3[0]}"

  # Binaries Install
  _check_bool "ae_task_bin" "${config__tasks__binaries[0]}"

  # snap Packages
  _check_bool "ae_task_snaps" "${config__tasks__snaps[0]}"


  if [[ ${bool_hide_config} != "true" ]] && [[ $AE_DEBUG -lt 1 ]]; then
    _line_fill
    printf "${_table} %-20s | %-10s |\n" "Repository" "Enabled"
    printf "${_cfg} %-20s | %-10s |\n" "Docker CE" "$add_docker_repo"
    printf "${_cfg} %-20s | %-10s |\n" "Wine-HQ" "$add_winehq_repo"
    printf "${_cfg} %-20s | %-10s |\n" "Google Cloud SDK" "$add_googlecloud_repo"
    printf "${_cfg} %-20s | %-10s |\n" "GCSFUSE" "$add_gcsfuse_repo"
    printf "${_cfg} %-20s | %-10s |\n" "Spotify" "$add_spotify_repo"
    printf "${_cfg} %-20s | %-10s |\n" "Skype" "$add_skype_repo"
    printf "${_cfg} %-20s | %-10s |\n" "Visual Studio Code" "$add_vscode_repo"
    printf "${_cfg} %-20s | %-10s |\n" "Insync" "$add_insync_repo"
    printf "${_cfg} %-20s | %-10s |\n" "Signal for Desktop" "$add_signal_repo"
    printf "${_cfg} %-20s | %-10s |\n" "Google Chrome, Earth" "$add_google_repo"
    printf "${_cfg} %-20s | %-10s |\n" "ROS" "$add_ros_repo"
    _line_fill;
    printf "${_table} %-20s | %-10s |\n" "Other Flags" "Config"
    _line_fill;
    printf "${_cfg} %-20s | %-10s |\n" "Purge Enabled" "$bool_purge_not_required_pkgs"
    printf "${_cfg} %-20s | %-10s |\n" "Keep DEBs/APT cache" "$bool_preserve_debs"
    printf "${_cfg} %-20s | %-10s |\n" "Uni-Freiburg Mirror" "$bool_use_uni_freiburg_mirror"
    _line_fill;

    # Only display tasks column when autopilot = true is set.
    if [[ ${AE_AUTOPILOT} == "true" ]]; then
      printf "${_table} %-20s | %-10s |\n" "Task" "Config"
      _line_fill;
      printf "${_rtasks} %-20s | %-10s |\n" "Update" "$ae_task_update"
      printf "${_rtasks} %-20s | %-10s |\n" "Upgrade" "$ae_task_upgrade"
      printf "${_rtasks} %-20s | %-10s |\n" "Add Repos" "$ae_task_repo"
      printf "${_rtasks} %-20s | %-10s |\n" "Add PPA" "$ae_task_ppa"
      printf "${_rtasks} %-20s | %-10s |\n" "APT packages" "$ae_task_apt"
      printf "${_rtasks} %-20s | %-10s |\n" "DEB packages" "$ae_task_debs"
      printf "${_rtasks} %-20s | %-10s |\n" "Purge packages" "$ae_task_purge"
      printf "${_rtasks} %-20s | %-10s |\n" "Python 2 Modules" "$ae_task_pip2"
      printf "${_rtasks} %-20s | %-10s |\n" "Python 3 Modules" "$ae_task_pip3"
      printf "${_rtasks} %-20s | %-10s |\n" "Static Binaries" "$ae_task_bin"
      printf "${_rtasks} %-20s | %-10s |\n" "Snap Packages" "$ae_task_snaps"
      _line_fill;
    fi
  else
    _log_debug "-------- REPO CONFIG ----------"
    _log_debug "Docker CE           : $add_docker_repo"
    _log_debug "Wine-HQ             : $add_winehq_repo"
    _log_debug "Google Cloud SDK    : $add_googlecloud_repo"
    _log_debug "GCSFUSE             : $add_gcsfuse_repo"
    _log_debug "Spotify             : $add_spotify_repo"
    _log_debug "Skype               : $add_skype_repo"
    _log_debug "Visual Studio Code  : $add_vscode_repo"
    _log_debug "Insync              : $add_insync_repo"
    _log_debug "Signal for Desktop  : $add_signal_repo"
    _log_debug "Google Chrome,Earth : $add_google_repo"
    _log_debug "ROS                 : $add_ros_repo"
    _log_debug "-------- FLAG CONFIG ----------"
    _log_debug "Purge Enabled       : $bool_purge_not_required_pkgs"
    _log_debug "Keep DEBs/APT cache : $bool_preserve_debs"
    _log_debug "Use Uni Mirror      : $bool_use_uni_freiburg_mirror"
    _log_debug "-------- TASK CONFIG ----------"
    _log_debug " AUTOPILOT IS ${AE_AUTOPILOT}"
    _log_debug "Update              : $ae_task_update"
    _log_debug "Upgrade             : $ae_task_upgrade"
    _log_debug "Add Repos           : $ae_task_repo"
    _log_debug "Add PPA             : $ae_task_ppa"
    _log_debug "APT packages        : $ae_task_apt"
    _log_debug "DEB packages        : $ae_task_debs"
    _log_debug "Purge packages      : $ae_task_purge"
    _log_debug "Python 2 Modules    : $ae_task_pip2"
    _log_debug "Python 3 Modules    : $ae_task_pip3"
    _log_debug "Static Binaries     : $ae_task_bin"
    _log_debug "Snap Packages       : $ae_task_snaps"
    _log_debug "--------  END CONFIG ----------"
  fi
  #################################################################################
  #                              Parse Arrays
  #################################################################################
  # Config file YAML has arrays of apt packages.
  # We need to parse apt packages, ppa's, deb packages, python modules listed in yaml
  # to bash arrays.

  #--------------------------------------------------------------------------------
  #                               APT Lists
  #--------------------------------------------------------------------------------
  # There are Seven lists under key config.install.apt.[mentioned from 1-7]
  # 1. administration : Contains Administrative packages
  # 2. security       : contains Security related tools and packages
  # 3. productivity   : Office tools, writing tools, LateX, document tools and other
  #                     productivity tools, Email clients, browsers, IM clients etc.
  #                   : Example : LateX, TeXStudio, Libre office, pandoc empathy, Thunderbird
  # 4. Multimedia     : Multimedia tools like media players, audio converters and playes etc.
  # 5. development    : IDEs [Spyder, Jetbeans etc], languages [go, python, ruby, rust, java etc],
  #                   : Containers [docker lxc rkt etc], Python libraries, compilers [gcc, clang]
  #                   : SDKs [AWS SDK, Coogle Cloud SDK, open-jdk, Tensor Flow], headers
  #                   : and libraries[ocl-icd-dev],
  #                   : Anything related to development and *-dev or *-devl packages.
  # 6. other          : Everything which doesnot fit in the above categories.
  #                   : Themes, Tools, Utilities like htop etc.
  # 7. External       : Any packages which are provided by ppas, or repositories not present in
  #                   : base *buntu distribution. There's a possibility that the repository might not
  #                   : be added or may be unavailable or offline. So Keeping the list seperate from
  #                   : others packages minimizes errors if there are any.
  # This classification is only for ease of use and need not be strictly followed. You can put
  # vlc package in 'security', it will still install fine. This classification helps
  # while writing configs and editing them. Its advised to follow it if your configs
  # tend to get to couple of hundreds of lines. Also YAML file should be a valid YAML.

  #--------------------------------------------------------------------------------
  #                             Special list - Purge list
  #--------------------------------------------------------------------------------
  # There is a special package list under key, config.purge or purge.list, which contains
  # list of apt packages to be purged from the system if present.
  # Lets get em, shall we?

  # Copy package array
  declare -gar parsed_purge_packages=("${config__purge_[@]}")
  declare -gar parsed_administration_packages=("${config__install__apt__administration_[@]}")
  declare -gar parsed_secutity_packages=("${config__install__apt__security_[@]}")
  declare -gar parsed_productivity_packages=("${config__install__apt__productivity_[@]}")
  declare -gar parsed_multimedia_packages=("${config__install__apt__multimedia_[@]}")
  declare -gar parsed_development_packages=("${config__install__apt__development_[@]}")
  declare -gar parsed_other_packages=("${config__install__apt__other_[@]}")
  declare -gar parsed_external_packages=("${config__install__apt__external_[@]}")

  #--------------------------------------------------------------------------------
  #                             PPA Lists
  #--------------------------------------------------------------------------------
  # Config file contains list of PPAs to be added under key
  # config.ppa
  declare -gar parsed_ppa_list=("${config__ppa_[@]}")

  #--------------------------------------------------------------------------------
  #                             Debian packages
  #--------------------------------------------------------------------------------
  # Config file contains list of DEB packages to be downloaded & installed under key
  # config.install.debian_packages
  # The configuration is not simple URL its csv. <URL to Deb file>,<Name of the Package>
  # This is for compatiblity reasons
  declare -gar parsed_deb_files_list=("${config__install__debian_packages_[@]}")

  #--------------------------------------------------------------------------------
  #                             Python Modules
  #--------------------------------------------------------------------------------
  # There are two keys under config.install.python(2/3) which contain Python 2 and Python 3
  # Modules respectively. Please donot mix python 2 Modules with Python 3.

  declare -gar parsed_pip2_packages=("${config__install__python2_[@]}")
  declare -gar parsed_pip3_packages=("${config__install__python3_[@]}")
  declare -gar parsed_bin_packages=("${config__install__binaries_[@]}")

  #--------------------------------------------------------------------------------
  #                             Snap Packages
  #--------------------------------------------------------------------------------
  declare -gar parsed_snap_normal_packages=("${config__install__snaps__normal_[@]}")
  declare -gar parsed_snap_classic_packages=("${config__install__snaps__classic_[@]}")
  declare -gar parsed_snap_edge_packages=("${config__install__snaps__edge_[@]}")

}


function _show_confirmation_dialog_for_tasks()
{
  # Function to confirm whether action selected should be performed or not.
  # Accepts 3 arguments
  # ARG-1 Name of the task/function selected
  # ARG-2 Message to be displayed in confirmation box
  # ARG-3 name of the function to execute
  # Depends on whiptail
  # To overide and say yes to all dialog pass -y as command line option while running the script.
  local name_of_task="${1}" #Name of the task to be performed
  local confirm_msg="${2}" #Message shown in Confirmation dialogue
  local exec_function="${3}" #Function to run if user selected yes
  COLUMNS=$(tput cols)
  LINES=$(tput lines)
  export COLUMNS LINES
  if [ "$bool_say_yes_to_all" != "true" ]; then
    _log_debug "Confirmation dialog is Necessary to get user approval to make changes for: $exec_function."
    # shellcheck disable=SC2086
    if (whiptail  --title "$name_of_task" --yesno "$confirm_msg" $LINES $COLUMNS $(( LINES - 12 ))) then
        _log_debug "User selected yes, Proceed with $name_of_task"
        # execute the function
        _log_debug "Executing: $exec_function"
        $exec_function
    else
        _log_debug "Selected No for $name_of_task , Returning to Main menu."
        _process_menu;
    fi
  elif [ "$bool_say_yes_to_all" = "true" ]; then
    _log_debug "Yes to all: No confirm dialog to be displayed."
    _log_debug "Executing: $exec_function"
    $exec_function;
  else
    _log_debug "Illegal value for bool_say_yes_to_all."
  fi
  unset exec_function
}


function _clean_apt_cache()
{
  # Function to clean apt package cache. Takes care of -k flag in all the installs.
  # Honor -k flag
  # Delete DEBs
  _log_debug "Cleaning APT packages..."
  if [ "$bool_preserve_debs" != "true" ];then
    _log_and_show "${_deleting} APT Cached Packages"
    apt-get -q clean | _add_timestamp_to_logs "${_apt_logs}"
  else
    _log_debug "Keeping cached APT Packages because -k flag is set."
  fi

}


function _install_dependencies()
{
  # Install packages mentioned in the arguments.
  # If installation fails exit the script.
  # ARG 1: Packages in quote separated by space.
  local packages=("$@")
  _log_debug "Installing Packages"
  {
    _log_debug "Following packages will be installed\n"
    _log_debug "[$(date)] ${_array} %s\n" "${packages[@]}"
  } >> "${log_file}"
  # Check if array is empty
  if [[ ${#packages[@]} -eq 0 ]]; then
    _log_warn "${_error} Package array is empty!" "19"
  else
    apt-get -q -y --no-install-recommends install "${packages[@]}" |& _add_timestamp_to_logs "${_apt_logs}"  \
    || _log_and_exit "${_error} Failed to install dependencies. Script cannot continue!!" "21"

    exit_status=$?
    if [ $exit_status -eq 0 ]; then
       _log_and_show "${_installed} dependency packages."
    else
      _log_warn "${_oh_no} Something went wrong while installing dependencies."
      _log_and_exit "${_notice} Please see the log file for more details." "21"
    fi
  _clean_apt_cache
  fi
}


function _install_pre_requisites()
{
  # This function installs required packages for adding apt repositories
  # These should be present in your base Ubuntu install. If not present then, this function
  # will install them.
  # Following are the packages installed by this function:
  # linux-image-extra-<>, apt-transport-https, ca-certificates,
  # curl, software-properties-common
  local pre_requisite_packages=(apt-transport-https ca-certificates curl gnupg2)
  _log_and_show "${_installing} Necessary dependencies..."
  _log_debug "Dependencies are apt-transport-https, ca-certificates, curl, gnupg2"
  _install_dependencies "${pre_requisite_packages[@]}"

}


function _fix_repo_not_available()
{
  # If repository is not available for latest Ubuntu release, this uses last stable release
  # (may not be LTS) for adding repository
  if [ "$bool_fix_repo_not_available_for_latest" == "true" ]; then
    # Only do this on latest releases
    if [ "$code_name" == "$code_name_latest_release" ]; then
      # check LTS fallback flag is being used
      if [ "$bool_fix_repo_lts" == "true" ]; then
        _log_warn "${_notice} Using LTS release ::${codename_lts_fallback}:: as fallback for --fix"
        code_name="$codename_lts_fallback"
      else
        _log_and_show "${_notice} Using previous release ${codename_previous_release} as fallback"
        code_name="$codename_previous_release"
      fi
    else
      _log_debug "This Release/Distro does not support this flag. --fix will be ignored."
    fi
  else
    _log_debug "Feature --fix/--fix-mode-lts is disabled."
  fi
}


function _fix_repo_not_available_upcoming_release()
{
  # If repository is not available for upcoming  release, this uses last stable release
  # Aka if the pre-release release is 18.04 it might use 17.10 if used with --fix, it will use 18.04 repos.
  # With Debian If release is 11, when used with this flag we will use Debian 10 repos.
  # --fix is not valid in case of Debian, only --pre-release applies.

  # check for fix-pre-release flag
  if [ "$bool_fix_repo_not_available_for_upcoming_release" == "true" ]; then

    # Only do this on upcoming-release
    if [ "$code_name" == "$codename_upcoming_release" ] && [ "$bool_is_debian" != "true" ]; then
      _log_warn "${_pre_release} Repositories from previous Ubuntu release are being used."
      set_yellow
      printf "${_pre_release} You need to modify this in Software and Updates,\n"
      printf "${_pre_release} when they become available for ${codename_upcoming_release}${NC}\n"
      set_default
        # If the repositories are  not available for latest stable release as well, go back a release.
        # Eg. If the pre-release is 18.04 and the repo is not available for 17.10 as well, we use 17.04 repositories.
        # Usually happens in first few days of development cycle of 18.04.
        if [ "$bool_fix_repo_not_available_for_latest" == "true" ]; then
          # We need to use repositories for previous stable release.
          _log_and_show "${_pre_release} Both falgs for --pre-release and -fix are set. Using codename: $codename_previous_release"
          code_name="$codename_previous_release"
        else
          # No need to apply fix for latest release, We can use latest stable release repositories
          _log_and_show "${_pre_release} Using repositories for current stable release: $code_name_latest_release"
          code_name="$code_name_latest_release"
        fi
    elif [ "$code_name" == "$codename_upcoming_debian_release" ] && [ "$bool_is_debian" == "true" ]; then
        _log_and_show "${_pre_release} Using repositories for current stable Debian release: $code_name_latest_debian_release"
        code_name="$code_name_latest_release"
    else
        _log_debug "This release/distribution does not support this option. Flag --pre-release will be ignored."
    fi
  else
    _log_debug "Feature fix_repo_not_available_upcoming_release is disabled."
  fi
}


function add_ppas()
{
  # Function to add ppa by reading ppas from ppa.list of from YAML key config.ppa
  # List/Config file should contain ppas in following format
  # ppa:ppa:<author>/<ppa> for example, ppa:mozillateam/firefox-nex for adding firefox next/Beta PPA
  _log_debug "Adding PPA Fucntion"
  local index;
  local _ppa_dependencies=(apt-transport-https ca-certificates curl gnupg2 software-properties-common)
  # Function Reads the file ${dir}/data/ppa.index and adds the ppa one by one.
  # Install dependencies required
  if [ "$bool_is_debian" != "true" ]; then
    _install_pre_requisites;
    _install_dependencies "${_ppa_dependencies[@]}"

      for index in "${parsed_ppa_list[@]}"; do
            _log_and_show "${_ppa} $index"
            # Check for empty lines
            if [ "$index" == "" ]; then
              _log_and_show "${_ppa} Found and empty entry Moving on to next.."
              continue
            fi
            if add-apt-repository -y "$index" |& _add_timestamp_to_logs "${_ppa_logs}" ; then
              _log_success "${_ppa} Success!"
            else
              _log_error "${_ppa} Some Error occured while adding $index. Ignoring and moving on.\n"
            fi
        done
  else
    _log_and_show "${_ppa} This is Debian. PPAs are not available."
  fi
  _line_fill >> "$log_file"
}


function add_repositories()
{
  # This function adds repositories for several apps like
  # Google Chrome, Spotify, Google Cloud SDK, GCSFUSE(Part of google cloud),
  # Skype, Docker, Skype, Microsoft Visual Studio Code, Google Earth, Insync client, Wine-HQ etc
  # WARNING: Some repositories might not support latest version of Ubuntu.

  #local CLOUD_SDK_REPO
  local GCSFUSE_REPO
  local exit_status
  # install dependencies required
  _install_pre_requisites;
  # if repository is not available for latest ubuntu release, use previous release
  # Be careful, things might not be compatible
  _fix_repo_not_available_upcoming_release;
  _fix_repo_not_available;
  _log_debug "Adding External Repositories"


  if [ "$ARCH" != "amd64" ]; then
    _log_notice "Chrome, Spotify, Insync, VSCode, Mendeley, signal and Duo Unix are only supported on 64 Bit"
  else
    _log_debug "Arch is 64 Bit Enable adding 64 bit repos."
    # 64 bit Only REPOS
    # Add Google Chrome and Google Earth
    if [ "$add_google_repo" == "true" ]; then
      _log_and_show "${_repo} Google Chrome & Google Earth"
      _log_debug "Adding Google package signing Key"
      wget -q  https://dl.google.com/linux/linux_signing_key.pub -O /tmp/ae/google_signing_key.pub >> $"$log_file"
      _log_debug "Adding Google key to trusted keys list"
      apt-key add /tmp/ae/google_signing_key.pub |& _add_timestamp_to_logs "${_apt_key_logs}" \
      || _log_warn "${_error} Adding trusted keys for Google failed."

      _log_and_show "${_repo} Google Chrome"
      echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main #Google-Chrome" > ${SOURCES_FILE_DIR}/google-chrome.list \
      || _log_warn "${_error} Adding Google Chrome Repository failed"

      _log_and_show "${_repo} Google Earth"

      echo "deb [arch=amd64] http://dl.google.com/linux/earth/deb/ stable main #Google-Earth" > ${SOURCES_FILE_DIR}/google-earth.list \
      || _log_warn "${_error} Adding Google Chrome repository failed"
    else
      _log_and_show "${_repo} Skipped Google chrome, Google Earth"
    fi


    # Spotify client
    if [ "$add_spotify_repo" == "true" ]; then
      _log_and_show "${_repo} Spotify"
      _log_debug "Adding Spotify keys"
      wget -q   https://download.spotify.com/debian/pubkey.gpg -O /tmp/ae/spotify_signing_key.pub >> $"$log_file"
      apt-key add /tmp/ae/spotify_signing_key.pub  2>&1 \
      |_add_timestamp_to_logs "${_apt_key_logs}"  \
      || _log_warn "${_error} Adding Spotify repository failed"

      echo "deb [arch=$ARCH] http://repository.spotify.com stable non-free #Spotify" > ${SOURCES_FILE_DIR}/spotify.list \
      || _log_warn "${_error} Adding Spotify Repository Failed"
    else
      _log_and_show "${_repo} Skipped Spotify."
    fi

    # Insync
    if [ "$add_insync_repo" == "true" ] && [ "$bool_is_debian" != "true" ]; then
      _log_and_show "${_repo} Insync"
      _log_debug "Adding Insync keys"
      apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys ACCAF35C  2>&1 \
      | _add_timestamp_to_logs "${_apt_key_logs}" \
      || _log_warn "${_error} Adding Insync Repository failed"

      echo "deb [arch=$ARCH] http://apt.insynchq.com/${distro_name} $code_name non-free contrib #Insync-Client" > ${SOURCES_FILE_DIR}/insync.list \
      || _log_warn "${_error} Adding Insync Repository failed"

    elif [ "$add_insync_repo" == "true" ] && [ "$bool_is_debian" == "true" ]; then
      _log_warn "${_whoops} InSync repositoris are not supported on Debian."
      _log_warn "${_info} Please use debfile instead of repositoris."
      _log_notice "${_info} Visit https://ae.prasadt.com/tasks/#install-debian-package-archives-deb-files"
    else
      _log_and_show "${_repo} Skipped InSync"
    fi


    # Google Cloud SDK and GCS-FUSE
    if [ "$add_googlecloud_repo" == "true" ] || [ "$add_gcsfuse_repo" == "true" ]; then
      _log_debug "Adding Google-Cloud repository sigining key"
      wget -q https://packages.cloud.google.com/apt/doc/apt-key.gpg -O /tmp/ae/googlecloud.gpg >> "$log_file"
      apt-key add /tmp/ae/googlecloud.gpg |& _add_timestamp_to_logs "${_apt_key_logs}"
    else
      _log_debug "Neither GCSFUSE nor Google cloud SDK install enabled. Not adding Google cloud APT keys"
    fi

    if [ "$add_googlecloud_repo" == "true" ]; then
      #CLOUD_SDK_REPO="cloud-sdk-${code_name}"
      _log_and_show "${_repo} Google-Cloud-SDK"
      echo "deb [arch=$ARCH] http://packages.cloud.google.com/apt cloud-sdk main #Google-Cloud-SDK" > ${SOURCES_FILE_DIR}/google-cloud-sdk.list  \
      || _log_warn "${_error} Adding Google Cloud SDK Repository failed"
    else
      _log_and_show "${_repo} Skipped Google Cloud SDK."
    fi

    if [ "$add_gcsfuse_repo" == "true" ]; then
      GCSFUSE_REPO="gcsfuse-${code_name}"
      _log_and_show "${_repo} GCSFUSE"
      echo "deb http://packages.cloud.google.com/apt $GCSFUSE_REPO main #GCSFUSE" > ${SOURCES_FILE_DIR}/gcsfuse.list  \
      || _log_warn "${_error} Adding GCSFUSE Repository failed"
    else
      _log_and_show "${_repo} Skipped GCSFUSE"
    fi

    # Skype
    if [ "$add_skype_repo" == "true" ]; then
      _log_and_show "${_repo} Skype for Linux"
      _log_debug "Getting Skype repository key"
      wget -q https://repo.skype.com/data/SKYPE-GPG-KEY -O /tmp/ae/skype-linux-key.gpg >> "$log_file"
      _log_debug "Adding Skype keys to trusted list"
      apt-key add /tmp/ae/skype-linux-key.gpg |& _add_timestamp_to_logs "${_apt_key_logs}" \
      || _log_warn "${_error} Adding Skype for linux key failed"
      echo "deb [arch=$ARCH] https://repo.skype.com/deb stable main #Skype" > $SOURCES_FILE_DIR/skype-stable.list \
      || _log_warn "${_error} Adding Skype for linux repository failed"
    else
      _log_and_show "${_repo} Skipped Skype for Linux."
    fi

    # Visual Studio Code
    if [ "$add_vscode_repo" == "true" ]; then
      _log_and_show "${_repo} Visual Studio Code"
      _log_debug "Getting GPG keys for repository"
      wget -q https://packages.microsoft.com/keys/microsoft.asc -O /tmp/ae/microsoft.asc
      _log_debug "Adding Key to trusted GPG keys directory"
      apt-key add /tmp/ae/microsoft.asc |& _add_timestamp_to_logs "${_apt_key_logs}" || _log_warn "${_error} Adding Visual Studio Code key failed"
      echo "deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main #Visual-Studio-Code" > ${SOURCES_FILE_DIR}/vscode.list
    else
      _log_and_show "${_repo} Skipped Visual Studio Code."
    fi

    # Signal App
    if [ "$add_signal_repo" == "true" ]; then
      _log_and_show "${_repo} Signal Desktop"
      wget -q https://updates.signal.org/desktop/apt/keys.asc -O /tmp/ae/signal.asc >> "$log_file"
      apt-key add /tmp/ae/signal.asc  |& _add_timestamp_to_logs "${_apt_key_logs}" \
      || _log_warn "${_error} Adding Signal Key Failed"
      echo "deb [arch=amd64] https://updates.signal.org/desktop/apt xenial main #Signal-for-Desktop"  > ${SOURCES_FILE_DIR}/signal-xenial.list
    else
      _log_and_show "${_repo} Skipped Signal Desktop."
    fi

    # Mendeley Desktop App
    if [ "$add_mendeley_repo" == "true" ]; then
      _log_and_show "${_repo} Mendeley Desktop"
      apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 6F036044 |& _add_timestamp_to_logs "${_apt_key_logs}" \
      || _log_warn "${_error} Adding Mendeley Desktop Key Failed"
      echo "deb [arch=$ARCH] https://desktop-download.mendeley.com/download/apt stable main #Mendeley-Desktop"  > ${SOURCES_FILE_DIR}/mendeleydesktop.list
    else
      _log_and_show "${_repo} Skipped Mendeley Desktop"
    fi

    # Duo Unix
    if [ "$add_duo_repo" == "true" ]; then
      _log_and_show "${_repo} Duo Security for Unix"
      case "$code_name" in
        bionic)     duo_repo_url="http://pkg.duosecurity.com/Ubuntu bionic main";
                    duo_supported="true"
                    ;;
        xenial)     duo_repo_url="http://pkg.duosecurity.com/Ubuntu xenial main"
                    duo_supported="true"
                    ;;
        trusty)     duo_repo_url="http://pkg.duosecurity.com/Ubuntu trusty main";
                    duo_supported="true"
                    ;;
        stretch)    duo_repo_url="http://pkg.duosecurity.com/Debian stretch main";
                    duo_supported="true"
                    ;;
        jessie)     duo_repo_url="http://pkg.duosecurity.com/Debian stretch main";
                    duo_supported="true"
                    ;;
        *)          _log_warn "${_warn} Only LTS/Stable versions of Ubuntu/Debian are suported."
                    _log_warn "${_warn} You are running Unsupported version : ${code_name}"
                    ;;
      esac
      if [[ $duo_supported == "true" ]]; then
        # Repo keys for duosecurity
        _log_debug "Downloading GPG key..."
        wget -q https://duo.com/APT-GPG-KEY-DUO  -O /tmp/ae/duosecurity.gpg >> "$log_file"
        apt-key add /tmp/ae/duosecurity.gpg |& _add_timestamp_to_logs "${_apt_key_logs}" \
        || _log_warn "${_error} Adding Duo Key Failed"

        # Add repo
        echo "deb [arch=$ARCH] ${duo_repo_url} #Duo Unix"  > ${SOURCES_FILE_DIR}/duounix.list
      fi
    else
      _log_and_show "${_repo} Duo Unix is set to false."
    fi

  # End if ARCH==64 Check
  fi

  #Wine HQ
  if [ "$add_winehq_repo" == "true" ]; then
    _log_and_show "${_repo} WineHQ"
    _log_debug "Getting WineHQ repository Key"
    wget -q https://dl.winehq.org/wine-builds/winehq.key -O /tmp/ae/wine-hq-sigining-key.key >> "$log_file"  2>&1
    _log_debug "Adding WineHQ key"
    apt-key add /tmp/ae/wine-hq-sigining-key.key |& _add_timestamp_to_logs "${_apt_key_logs}" \
    || _log_warn "${_error} Adding WineHQ keys failed"
    _log_debug "Adding WineHQ repository"
    echo "deb https://dl.winehq.org/wine-builds/${distro_name}/ ${code_name} main #WineHQ" > ${SOURCES_FILE_DIR}/winehq.list \
    || _log_warn "${_error} Adding WineHQ repository failed"
  else
    _log_and_show "${_repo} Skipped WineHQ."
  fi

  # Docker CE
  if [ "$add_docker_repo" == "true" ]; then
    if [ "$ARCH" == "amd64" ] || [ "$ARCH" == "armhf" ]; then
      _log_and_show "${_repo} Docker-CE"
      _log_debug "Getting Docker-CE repository Key"
      wget -q https://download.docker.com/linux/"${distro_name}"/gpg -O /tmp/ae/docker-key.gpg >> "$log_file"  2>&1
      _log_debug "Adding Docker repository key"
      apt-key add /tmp/ae/docker-key.gpg |& _add_timestamp_to_logs "${_apt_key_logs}" \
      || _log_warn "${_error} Adding Docker-CE keys failed"
      _log_debug "Adding Docker-CE sources .list"
      echo "deb [arch=$ARCH] https://download.docker.com/linux/${distro_name}  ${code_name} stable #Docker-Community-Edition" > ${SOURCES_FILE_DIR}/docker.list \
      || _log_warn "${_error} Adding Docker-CE repository failed"
    else
      _log_warn "${_error} Architecture not supported!. Please use docker.io package from your distro."
    fi
  else
    _log_debug "Skipped Docker-CE"
  fi



  # ROS
  # Arch support varies on distro so lot of ugly elifs.
  # Packages share same name across RC and Stable. so its not possible to
  # use both RC(ros-shadow-fixed and ros) repos at the same time.
  # rusty will reach EOL soon, ITs not supported and its complicated due to
  # http://wiki.ros.org/indigo/Installation/Ubuntu
  # Dependency issues which might pop up.
  ros_arch_supported="false"


  if [ "$add_ros_repo" == "true" ]; then

    # Distro/Version/Arch checks
    if [[ $distro_name == "ubuntu" ]]; then
        # Check architectures
        # Bionic
        if [[ $code_name == "bionic" ]]; then
          if [[ $ARCH == "amd64" ]] || [[ $ARCH == "arm64" ]] || [[ $ARCH == "armhf" ]]; then
            ros_arch_supported="true"
            _log_and_show "${_repo} ROS is available on Bionic/$ARCH"
          fi

        elif [[ $code_name == "xenial" ]]; then
          if [[ $ARCH == "amd64" ]] || [[ $ARCH == "arm64" ]] || [[ $ARCH == "armhf" ]] || [[ $ARCH == "i386" ]]; then
            ros_arch_supported="true"
            _log_and_show "${_repo} ROS is available on Xenial/$ARCH"
          fi
        fi
    fi #ubuntu

    if [ "$distro_name" == "debian" ]; then
        # Check architectures
        # stretch | jessie
        if [[ $code_name == "stretch" ]] || [[ $code_name == "jessie" ]]; then
          if [[ $ARCH == "amd64" ]] || [[ $ARCH == "arm64" ]] ; then
            ros_arch_supported="true"
            _log_and_show "${_repo} ROS is available on Debian ${code_name}/$ARCH"
          fi
        fi
    fi #debian

    if [[ $ros_arch_supported == "true" ]]; then
      _log_and_show "${_repo} ROS is Supported on this distro/ARCH : ${code_name}/${ARCH}"
      _log_debug "Adding ROS repo key(latest)..."
      apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 |& _add_timestamp_to_logs "${_apt_key_logs}"  \
       || _log_warn "${_error} Adding ROS repository key failed!"

       if [[ $bool_use_uni_freiburg_mirror == "true" ]] && [[ $distro_name == "ubuntu" ]]; then
         _log_warn "Using Uni-Freiburg Mirror! This mirror might not be upto date with primary ROS repository!."
         _log_warn "You may need authentication or have to be inside Uni-Freiburg network!"
         echo "deb http://packages.ros.org.ros.informatik.uni-freiburg.de/ros/ubuntu ${code_name} main #ROS-Repo-Uni-Freiburg" > $SOURCES_FILE_DIR/ros-latest.list \
         || _log_warn "${_error} Adding ROS [Uni-Freiburg] repository failed!"
      else
        echo "deb http://packages.ros.org/ros/ubuntu ${code_name} main #ROS-Repo" > $SOURCES_FILE_DIR/ros-latest.list \
        || _log_warn "${_error} Adding ROS repository failed!"
       fi

    else
      _log_warn "${_repo} ROS is not supported on this distro/architecture!"
    fi # ros_arch_supported

  else
    _log_and_show "${_repo} Adding ROS repository is set to false, skipping..."
  fi # add_ros_repo


  # Enable Canonical Partner repos
  # Some Releases like linux mint have their own way of enabling partner repositories,
  # Disable adding partner Repositoris when using Ubuntu Derivatives like Linux Mint.
  # Default is true
  # _fix_ubuntu_derivatives will take care of this and bool_config_partner_repo is set to true only if
  # Ubuntu and its flavors are used.
  if [ "$bool_config_partner_repo" == "true" ] && [ "$bool_is_debian" != "true" ]; then
    _log_and_show "${_repo} Canonical partner repositoris"
    echo "deb http://archive.canonical.com/ubuntu $code_name partner # Canonical Partner Repository"  > ${SOURCES_FILE_DIR}/canonical-partner.list \
    || _log_error "${_error} Failed to add Canocial Parner Repos."
  else
    _log_warn "${_warn} Canonical Partner repositories may not be supported on this platform."
  fi

  # Remove artifacts and keys
  _log_debug "Removing keys and converted files from current directory"
  (
    rm  -f /tmp/ae/*.gpg /tmp/ae/*.asc /tmp/ae/*.pub /tmp/ae/Release \
        /tmp/ae/*.Release /tmp/ae/*.key /tmp/ae/*.pub.* /tmp/ae/*.asc.* \
        /tmp/ae/*.key.* /tmp/ae/*.gpg.* >> "$log_file"
  )
  _line_fill >> "$log_file"

  update_repos

}


function update_repos()
{
  local exit_status
  _log_and_show "${_update} Repository index/metadata..."
  apt-get -q update |& _add_timestamp_to_logs "${_apt_logs}"
  exit_status=$?
  if [[ $exit_status -eq 0 ]]; then
    _log_success "${_update} Success!"
  else
    _log_error "${_oh_no} Something went wrong in updating repo data. Please see the log file for more details."
    _log_error "${_error} Your system might end up completely broken and apt-get isn't reliable in this state."
    _log_error "${_error} The script cannot proceed with this."
    _log_and_exit "${_notice} Most of the times its either missing repository keys or wrongly configured repositories." "61"
  fi
}


function upgrade_apps()
{
  # This function will list up-gradable apps and upgrade it.
  # IF Simulate is set to true this will only list the apps but no upgrade action will be performed.
  local exit_status
  _log_and_show "${_upgrade} Packages..."
  _log_trace "List of upgradable packages if any is listed below."
  _line_fill >> "$log_file"
  # upgradable is not available in apt-get ignore warning about apt being unstable
  apt list --upgradable |& _add_timestamp_to_logs "${_apt_logs}"  \
  || _log_and_show "Something went wrong while listing upgradable packages. Please see the log file or run in debug mode for details."

  _log_debug "The list of packages will be upgraded!"
  # only do upgrades if simulate is set to false
  if [ "$simulate_apt_install" != "true" ]; then

    DEBIAN_FRONTEND=noninteractive apt-get -q -y upgrade |& _add_timestamp_to_logs "${_apt_logs}"
    DEBIAN_FRONTEND=noninteractive apt-get -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" --allow-remove-essential --allow-change-held-packages -fuy dist-upgrade \
    | _add_timestamp_to_logs "${_apt_logs}"
    exit_status=$?
  else
    # If  simulate is true, set exit status as 0
    # Simulate flag skips the section above. No point in Checking for exit status
    _log_notice "${_simulate} is set to True. Not performing upgrade!"
    exit_status=0
  fi
  if [[ $exit_status -eq 0 ]]; then
    _log_success "${_upgrade} Completed successfully!"
  else
    _log_warn "${_oh_no} Something went wrong while upgrading packages."
    _log_warn "${_notice} Please see the log file for more details. \
    Most of the times its either missing repositories or wrongly configured repositories."
  fi
  set_default;
  # Cleanup APT cache (-k)
  _clean_apt_cache;

  _line_fill >> "$log_file"
}


function  upgrade_system()
{
  _log_debug "Updating and upgrading packages"
  update_repos;
  upgrade_apps;
}


function purge_ppa()
{
  # PPAs added or repositories added by actions other than this script are not removed.
  # Simulate option has no effect on this function. PPAs will be purged irrespective of its value.
  local exit_status index dependency_packages
  dependency_packages=(ppa-purge)

  if [ "$enable_ppa" == "true" ]; then
    _log_and_show "${_purge} PPAs"
    _install_dependencies "${dependency_packages[@]}"
      for index in "${parsed_ppa_list[@]}"; do
            _log_and_show "${_purge} $index..."
            _log_debug "Purging: $index"
            if [ "$index" == "" ] || [ "$index" == " " ]; then
              _log_warn "${_purge} Found an empty entry, Ignoring"
              continue;
            fi
            if ppa-purge -y "$index"  |& _add_timestamp_to_logs "${_apt_logs}"  ; then
              sleep 5 #wait sometimes apt lock isnt released soon.
              _log_success "${_purge} $line successfully."
            else
              _log_warn "${_oh_no} Some Error occured while purging $line."
            fi
        done
      _log_warn "${_purge} External PPAs."

      # Clean -k flag.
      _clean_apt_cache;
      _log_and_show "${_purge} Complete. Please check the logs for errors."

  else
    _log_warn "PPA's are not available for this release/distro"
  fi
}


function disable_external_repos()
{
  # Function to disable external repositories added by this script.
  # PPAs added or repositories added by actions other than this script are not removed.
  # Repositories added by dpkg post install scripts and deb files will not be removed!!
  # Simulate option has no effect on this function. PPAs will be purged irrespective of its value.

    # Remove keys and list files.
    _log_and_show "${_deleting} Keys and external repositories"
    _log_and_show "${_info} You can igore failed messages if those were not added in first place."
    set_default
    _log_and_show "${_deleting} Google signing key   7FAC5991"
    apt-key del 7FAC5991  |& _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_warn "${_deleting}  Google signing key -1 failed."

    _log_and_show "${_deleting} Google signing key   D38B4796"
    apt-key del D38B4796  |& _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_warn "${_deleting}  Google signing key -2 failed."

    _log_and_show "${_deleting} GCP signing key -2   BA07F4FB"
    apt-key del BA07F4FB  |& _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_warn "${_deleting}  Google cloud key -1 failed."

    _log_and_show "${_deleting} GCP signing key -2   A7317B0F"
    apt-key del A7317B0F  |& _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_warn "${_deleting}  GCP signing key -2  failed."

    _log_and_show "${_deleting} Spotify signing key  E130D1D45"
    apt-key del E130D1D45  |& _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_warn "${_deleting}  Spotify signing key failed."

    _log_and_show "${_deleting} WineHQ key [latest]  F987672F"
    apt-key del F987672F  |& _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_warn "${_deleting}  WineHQ keys [latest] failed."

    _log_and_show "${_deleting} InSync signing key   ACCAF35C"
    apt-key del ACCAF35C  |& _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_warn "${_deleting}  InSync keys failed."

    _log_and_show "${_deleting} Docker signing key   0EBFCD88"
    apt-key del 0EBFCD88  |& _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_warn "${_deleting}  Docker-CE keys failed."

    _log_and_show "${_deleting} VS-Code signing key  BE1229CF"
    apt-key del BE1229CF  |& _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_warn "${_deleting}  Visual Studio Code keys failed."

    _log_and_show "${_deleting} Signal signing key   57F6FB06"
    apt-key del 57F6FB06  |& _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_warn "${_deleting}  Signal keys failed."

    _log_and_show "${_deleting} Mendeley signing key 6F036044"
    apt-key del 57F6FB06  |& _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_warn "${_deleting}  Mendeley Desktop keys failed."

    _log_and_show "${_deleting} ROS signing key B01FA116"
    apt-key del 421C365BD9FF1F717815A3895523BAEEB01FA116  |& _add_timestamp_to_logs "${_apt_key_logs}"  \
    || _log_warn "${_deleting}  ROS keys failed."

    _log_and_show "${_repo} Removing external repositoris"
    _log_debug "${_deleting} *.list and *.save files from ${SOURCES_FILE_DIR}"
    (
      cd /etc/apt/sources.list.d &&
        rm  -f google-chrome.* \
        google-earth.* \
        skype-stable.* \
        spotify.* \
        insync.* \
        google-cloud-sdk.* \
        gcsfuse.* \
        docker.* \
        winehq.* \
        vscode.* \
        signal-xenial.* \
        mendeleydesktop.* \
        ros-latest.*
    )
    exit_status=$?

    if [[ $exit_status -eq 0 ]]; then
      _log_and_show "${_removed} Additional APT keys and repositories."
      _log_and_show "${_notice} Canonical partner repository was left unchanged."
    else
      _log_warn "${_oh_no} Failed to remove all or some of the list files or keys in Sources directory."
      _log_warn "${_notice} Please see the log file for more details."
    fi
    _log_notice "${_removed} Repositories. Please check the logs for errors."

    _line_fill >> "$log_file"

}

function purge_not_required()
{
  # This function purges not required packages from the list ${dir}/data/purge.list
  # A flag -d MUST be passed for this option to work
  # Not passing a flag and choosing purge will result in error and action being aborted.
  # Simulate is not properly tested and use it with caution!
  # Combination of simulate and purge is UNSTABLE
  # You can modify -d requirement by setting the d_flag_passed=true
  # No validation/checks are done on the list file.
  # Action is dangerous if used carelessly eg. If you are stupid and remove say sudo (why would you??)

  local exit_status
  if [ "$bool_purge_not_required_pkgs" == "true" ]; then
    _log_and_show "${_purge} Packages..."

    if [[ ${#parsed_purge_packages[@]} -eq 0 ]]; then
      _log_warn "${_error} Package array is empty!";
      return;
    else
      if [ "$simulate_apt_install" == "true" ]; then
        _log_warn "${_simulate} Purging will be simulated!!"
      apt-get -q -y remove --purge --dry-run "${parsed_purge_packages[@]}" |& _add_timestamp_to_logs "${_apt_logs}"
      else
        apt-get -q -y purge "${parsed_purge_packages[@]}" |& _add_timestamp_to_logs "${_apt_logs}"
      fi
      exit_status=$?

      if [[ $exit_status -eq 0 ]]; then
        _log_success "${_purge} Success!"
      else
        _log_warn "${_oh_no} Something went wrong while purging packages."
        _log_warn "${_notice} Please see the log file for more details."
      fi
    fi

  else
    _log_and_exit "${_error} Purge switch is set to false. Did you pass -d along with the command?" "20"
  fi
  _line_fill >> "$log_file"

}


function install_apps()
{
  # Function to install apps mentioned in arrays
  # external-repos should always be at last to avoid any errors in previous .
  # No checks are being made on any of the files for validity. One entry per line is recommended.
  # If a package is not available entire collection in the file *.list will not be installed!!

  # Accept some EULA
  update_repos;
  echo ttf-mscorefonts-installer msttcorefonts/accepted-mscorefonts-eula select true |  debconf-set-selections
  #Install starts here
  local packages exit_status index
  #shellcheck disable=SC2034
  readonly local package_arrays=(
                              administration
                              security
                              productivity
                              multimedia
                              development
                              other
                              external
                              )
  for array in "${package_arrays[@]}"; do
    case "${array}" in
      administration)         packages=("${parsed_administration_packages[@]}");;
      security)               packages=("${parsed_secutity_packages[@]}");;
      productivity)           packages=("${parsed_productivity_packages[@]}");;
      multimedia)             packages=("${parsed_multimedia_packages[@]}");;
      development)            packages=("${parsed_development_packages[@]}");;
      other)                  packages=("${parsed_other_packages[@]}");;
      external)               packages=("${parsed_external_packages[@]}");;
      *)                      _log_and_exit "${_error} Critical error. Invalid array type" "19";;
    esac
    _log_and_show "${_apt} Installing $array packages"

    # Chek if array is empty
    if [[ ${#packages[@]} -eq 0 ]]; then
      _log_warn "${_notice} Package array is empty!";
      continue
    else
      _log_debug "Following packages will be installed."
      printf "[$(date)] ${_array} %s\n" "${packages[@]}" >> "${log_file}"
      # Check if simulate is true
      if [ "$simulate_apt_install" == "true" ]; then
        _log_warn "${_simulate} package installation."
        apt-get -q -y install -s "${packages[@]}" | _add_timestamp_to_logs "${_apt_logs}"
      else
        apt-get -q -y install "${packages[@]}" | _add_timestamp_to_logs "${_apt_logs}"
      fi
      exit_status=$?
      unset packages;
      if [[ $exit_status -eq 0 ]]; then
        _log_success "${_apt} Success!"
      else
      _log_warn "${_oh_no} Something went wrong while installing packages in $array."
      _log_warn "${_notice} Please see the log file for more details."
      fi

    fi
    unset packages
  done
  {
    _line_fill
    #declare -p
    _line_fill
  } >> "$log_file"
  # Delete DEBs
  _clean_apt_cache;

  _line_fill >> "$log_file"
}


function _install_pip_python()

{
  # Function to install python pip packages
  # This function reads from File ${dir}/data/pip.list contains list python packages to be installed system wide.
  # Arguments : Two
  # ARG1 : pip package list
  # ARG2 : 2 for python 2 and
  #      : 3 for Python 3.

  #Check args
  if [ $# -lt 1 ] ||  [ $# -gt 1 ] ; then

    _log_warn "${_error} Incorrect number of arguments.\
     \n${_info} Usage: _check_and_install_pre_requisites <list.apt> <commands to check>\n" && \
    _log_and_exit "Internal Function Error. Invalid number of Arguments: $#." "19";
  fi;


  #Install starts here
  local exit_status pip_command pip_loc python_packages requirements_file
  local pip_ver="${1}"
  _log_debug "Option: Install Python packages via PIP, Function name: _install_pip_python"
  _log_debug "pip Version : ${pip_ver}"

  # Check Python Version
  case ${pip_ver} in
    2 | python2 )   readonly pip_command="pip"
                    dependency_packages=(python-pip python-setuptools)
                    python_packages=("${parsed_pip2_packages[@]}")
                    requirements_file="/tmp/ae/requirements2.txt"
                    ;;
    3 | python3 )   readonly pip_command="pip3";
                    dependency_packages=(python3-pip python3-setuptools)
                    python_packages=("${parsed_pip3_packages[@]}")
                    requirements_file="/tmp/ae/requirements3.txt"
                    ;;
              * )   _log_and_exit "Internal Function Error. Arguments for python version." "19";;
  esac

  _log_and_show "${_checking} Dependencies for Python: ${pip_ver}"

  # Check if `python-pip` is installed, if not install it
  if ! pip_loc="$(type -p "$pip_command")" || [[ -z $pip_loc ]]; then
      _log_warn "${_info} $pip_command is not installed!${NC}"
      update_repos;
      _log_and_show "${_installing} PIP Dependencies"

      # Check if simulate flag is set
      if [ "$simulate_apt_install" == "true" ] && [ "$AE_INTERNAL_CI_MODE" != "true" ]; then
        _log_warn "${_simulate} No Dependencies will be installed!!"
        # shellcheck disable=SC2086
        apt-get -q -y -s --no-install-recommends install "${dependency_packages[@]}" |& _add_timestamp_to_logs "${_apt_logs}"
      elif [ "$simulate_apt_install" == "true" ] && [ "$AE_INTERNAL_CI_MODE" == "true" ]; then
        _log_dev "This is CI disregarding --simulate flag for installing pip dependencies"
        apt-get -q -y --no-install-recommends install "${dependency_packages[@]}" |& _add_timestamp_to_logs "${_apt_logs}"
      else
        # shellcheck disable=SC2086
        apt-get -q -y --no-install-recommends install "${dependency_packages[@]}" |& _add_timestamp_to_logs "${_apt_logs}"
      fi
      exit_status=$?

      if [[ $exit_status -eq 0 ]]; then
        _log_success "${_installed} Dependency packages."
      else
        _log_warn "${_oh_no} Something went wrong while installing dependencies."
        _log_warn "${_error} Python packages cannot be installed without dependencies."
        _log_and_exit "${_notice} Please see the log file for more details." "21"
      fi

      ## honor --keep-debs -k flags
      _clean_apt_cache;

  else
    _log_and_show "${_info} Dependency already satisfied."
  fi
  # reset exit status & color
  exit_status=0
  set_default;


  _log_and_show "${_installing} Installing python packages"
  _log_debug "Requirements file: ${requirements_file}"
   rm -f ${requirements_file} || _log_and_exit "Failed to remove ${requirements_file}" "38"
   printf "%s\n" "${python_packages[@]}" > "${requirements_file}"
  # Check if pip package list is empty
  if [[ ${#python_packages[@]} -eq 0 ]]; then
    _log_warn "${_error} Package array is empty!";
    return
  else
    # I package list isn't empty proceed to install pip packages
    # Check if simulate is true & is not running on TRAVIS/CI.
    if [ "$simulate_apt_install" == "true" ] && [ "$AE_INTERNAL_CI_MODE" != "true" ]; then
      _log_warn "${_whoops} PIP does not support simulated installs. Not performing install."
    elif  [ "$simulate_apt_install" == "true" ] && [ "$AE_INTERNAL_CI_MODE" == "true" ]; then
      _log_dev "This is CI disregarding simulate for pip action"
      $pip_command install -r "${requirements_file}" |& _add_timestamp_to_logs "${_pip_logs}"
    else
      _log_debug "Installing requirements file ${requirements_file}"
      $pip_command install -r "${requirements_file}" |& _add_timestamp_to_logs "${_pip_logs}"

    fi
    exit_status=$?
    if [[ $exit_status -eq 0 ]]; then
      _log_success "${_installed} python - ${1} modules"
    else
      _log_warn "${_error} Something went wrong while installing packages in $pip_list."
      _log_warn "${_notice} Please see the log file for more details."
    fi
  fi

  _line_fill >> "$log_file"
}


function install_pip_packages_2()
{
  # Install Python 2 packages
  if [[ $python2_disabled == "true" ]]; then
    _log_error "${_error} Python2 is not supported on this platform!"
  else
    _install_pip_python "2"
  fi
}


function install_pip_packages_3()
{
  # Install Python 2 packages
  _install_pip_python "3"
}


function install_debs ()
{

  # Function to get the deb files from DEB_URL in the ${dir}/data/deb_files.list
  # The list file has following format
  # URL to get the deb file  <space or tab> NAME_OF_THE_APP(without spaces)

  local index deb_url line deb_name
  local exit_status
  _log_debug "Option: Install DEB Files, Function name: install_debs"
  for index in "${parsed_deb_files_list[@]}"; do
    _log_debug "$index"
    deb_url=$(echo "$index" | cut -d ',' -f1 )
    deb_name=$(echo "$index" | cut -d ',' -f2 )
    _log_debug "DEB file url: $deb_url"
    _log_debug "DEB file name: $deb_name"

    if [[ -z $deb_url ]] || [[ -z $deb_name ]]; then
      _log_error "${_error} Malformed entry either URL or name is empty!"
      continue
    fi

    _log_and_show "${_deb} Downloading $deb_name"
    {
      wget -q "$deb_url" -O "${deb_name}" >> "$log_file"
    } ||
    {
      _log_error "${_error} Downloading $deb_name failed."
      continue
    }

   _log_and_show "${_deb} Installing - $deb_name..."
   # Check if simulate is true
   if [ "$simulate_apt_install" == "true" ]; then
     _log_warn "${_simulate} $deb_name Installation!!"
     dpkg -i --dry-run "$deb_name" |& _add_timestamp_to_logs "${_dpkg_logs}"

     _log_debug "Installing missing packages..."
     apt-get -q -y install -f |& _add_timestamp_to_logs "${_apt_logs}"
     exit_status=$?
    else
      dpkg -i "$deb_name" |& _add_timestamp_to_logs "${_dpkg_logs}"
      _log_debug "Installing missing packages..."
      apt-get -q -y install -f |& _add_timestamp_to_logs "${_apt_logs}"
      exit_status=$?
    fi

    # shellcheck disable=SC2181
     if [ "$exit_status" = "0" ]; then
      _log_success "${_deb} Installed $deb_name successfully."
     else
      _log_warn "${_oh_no} Some error occurred during downloading and installing $index."
      $?="0"
    fi
    # Delete DEBs
    if [ "$bool_preserve_debs" == "false" ];then
      _log_and_show "${_deb} Deleting downloaded DEB Packages"
      (
        rm -f "${dir}/${deb_name}" >> "$log_file"
      )
    else
      _log_debug "Keeping downloaded DEB packages"
    fi
  done

  _clean_apt_cache;
  _line_fill >> "$log_file"
}


function install_binaries ()
{

  # Function to get the binaries files from URL in the ${dir}/data/bin.list
  # The list file has following format
  # <URL>,<filename>
  # If you want to specify relative path you
  # can do so relative to /usr/local/bin
  # Be careful not to rename existing ones

  local index bin_url line bin_name
  local exit_status
  _log_debug "Option: Install Bin Files, Function name: install_binaries"
  # Check if simulate is true
  for index in "${parsed_bin_packages[@]}"; do
    _log_debug "$index"
    bin_url=$(echo "$index" | cut -d ',' -f1 )
    bin_name=$(echo "$index" | cut -d ',' -f2 )
    _log_debug "BIN file url: $bin_url"
    _log_debug "BIN file name: $bin_name"

    if [[ -z $bin_url ]] || [[ -z $bin_name ]]; then
      _log_error "${_error} Malformed entry either URL or name is empty!"
      continue
    fi
    _log_and_show "${_info} Downloading $bin_name"
    wget -q "$bin_url" -O "/tmp/ae/${bin_name}" >> "$log_file"
    exit_status="$?"
    if [ $exit_status -eq 0 ]; then
      _log_and_show "${_installing} $bin_name..."
       if [ "$simulate_apt_install" == "true" ]; then
         _log_warn "${_simulate} Skipping Installation!!"
       else
        {
          cp -rf "/tmp/ae/${bin_name}" /usr/local/bin/"${bin_name}"
        } || _log_and_show "${_error} Failed to copy $bin_name";
        _log_debug "Setting Permissions..."
        chmod +x /usr/local/bin/"$bin_name" >> "${log_file}"
      fi
    else
      _log_error "${_error} Failed to download $bin_name."
    fi
    set_default
  done
  _line_fill >> "$log_file"
}


function __install_snaps()
{
  #Install Snap packages
  local exit_status index snapd_options
  local snap_type
  snap_type="$1"

  case ${snap_type} in
    classic)    snapd_options=("--color=never" "--classic")
                parsed_snaps_list=("${parsed_snap_classic_packages[@]}")
                ;;
    edge)       snapd_options=("--color=never" "--edge")
                parsed_snaps_list=("${parsed_snap_edge_packages[@]}")
                ;;
    normal)     snapd_options=("--color=never")
                parsed_snaps_list=("${parsed_snap_normal_packages[@]}")
                ;;
    * )         _log_and_exit "Internal Function Error. Arguments for snap type." "19";;
  esac

  if [[ ${#parsed_snaps_list[@]} -eq 0 ]]; then
      _log_warn "${_warn} Snaps array is empty!" "19"
  else
    for index in "${parsed_snaps_list[@]}"; do
      _log_and_show "${_snap} $index..."
      if [ "$index" == "" ] || [ "$index" == " " ]; then
        _log_warn "${_snap} Found an empty entry, Ignoring"
        continue;
      fi

      if [ "$simulate_apt_install" == "true" ]; then
        _log_warn "${_info} Snaps do not support --dry-run, skipping install"
      else
        _log_debug "Options are ${snapd_options[*]}"
        if snap install "${snapd_options[@]}" "$index"  |& _add_timestamp_to_logs "${_snap}"  ; then
          _log_success "${_snap} $line installed successfully."
        else
          _log_warn "${_oh_no} Some Error occurred while installing $line."
        fi
      fi
    done
  fi
}


function install_snaps()
{
  local dependency_packages
  dependency_packages=(snapd)

  if [ "$simulate_apt_install" == "true" ]; then
    _log_warn "${_warn} Will not install dependencies required for installing snap packages"
  else
    _install_dependencies "${dependency_packages[@]}"
  fi

  _log_and_show "${_info} Installing Snaps [Normal Packages]"
  __install_snaps "normal"
    _log_and_show "${_info} Installing Snaps [Classic Packages]"
  __install_snaps "classic"
    _log_and_show "${_info} Installing Snaps [Edge Packages]"
  __install_snaps "edge"

}

function _autopilot_check_task_flag_and_run()
{
  # checks flags set for each task/function and runs it
  # Arguments Two
  # ARG -1 : global flag variable to check
  # ARG -2: Function Name to execute
  local flag=${1}
  local runnable=${2}

  if [ "${flag}" == "true" ]; then
    _log_debug "Executing Function $runnable"
    "$runnable"
  else
    _log_debug "Task : $runnable is not enabled"
  fi
  unset runnable
}


function all_in_one()
{
  #Wrapper for all options
  _log_debug "Option: ALL IN ONE, function name: all_in_one"
  _line_fill;
  set_default;
  update_repos;
  upgrade_apps;
  add_ppas;
  add_repositories;
  install_apps;
  install_debs;
  install_pip_packages_2;
  install_pip_packages_3;
  purge_not_required;
  install_binaries;
  install_snaps;
  set_default;
  _line_fill;

}


function _process_menu
{
  local whiptail_exitstatus task COLUMNS LINES
  _log_debug "Processing Options"
  COLUMNS=$(tput cols)
  LINES=$(tput lines)
  #export COLUMNS LINES
  # shellcheck disable=SC2086
  task=$(whiptail \
      --notags \
      --backtitle "$SCRIPT" \
      --title "Ubuntu Post-Install Script" \
      --menu "\nWhat would you like me to do?\nCheck the logs for details and errors." \
      --cancel-button "Quit" \
      $LINES $COLUMNS $(( LINES - 12 )) \
      update     'Update Repository Metadata' \
      upgrade    'Upgrade Packages' \
      all        'APT+PIP+PPA+REPO+DEB=All' \
      repo       'Add Repositories' \
      ppas       'Add PPAs' \
      purge      'Purge not required packages' \
      apps       'Install Packages' \
      debs       'Install DEB packages' \
      pip2       'Install Python 2 packages via pip' \
      pip3       'Install Python 3 packages via pip3' \
      bin        'Download & Install Static Binaries' \
      repo_rst   'Reset Repositories for cleanup' \
      ppa_rst    'Purge PPAs' \
      snaps      'Install snap packages' \
      logdel     'Delete Script logs' \
      3>&1 1>&2 2>&3)

    whiptail_exitstatus=$?
    _log_debug "Whiptail Exit status is : $whiptail_exitstatus"
    if [ $whiptail_exitstatus = 0 ]; then
      _log_debug "Whiptail Choice is: $task"
      case $task in
      update)     _show_confirmation_dialog_for_tasks \
                  "Update APT index" \
                  "Update Repositories index/metadata?" \
                  "update_repos"
                  ;;
      upgrade)    _show_confirmation_dialog_for_tasks \
                  "Upgrade Packages" \
                  "This will upgrade all installed packages to the latest version.\n\nContinue?"
                  "upgrade_apps"
                  ;;
      ppas)       _show_confirmation_dialog_for_tasks "Add Additional PPAs" \
                  "This will add PPAs specified in config file.\n\nWould you like to continue?" \
                  "add_ppas"
                  ;;
      repo)       _show_confirmation_dialog_for_tasks "Add Additional Repositories" \
                  "Adding additional repositories is set as follows.\n Google Chrome & Google Earth : $add_google_repo,\n Google Cloud SDK : $add_googlecloud_repo\n GCSFUSE : $add_gscfuse_repo \nVisual Studio Code : $add_vscode_repo\n Docker : $add_docker_repo\n Insync : $add_insync_repo\n Spotify : $add_spotify_repo\n Wine-HQ : $add_winehq_repo\n Skype : $add_skype_repo\n Signal Desktop : $add_signal_repo.\n Shall I do it?" \
                  "add_repositories"
                  ;;
      apps)       _show_confirmation_dialog_for_tasks \
                  "Install Apps" \
                  "I can Install the packages listed in config file.\nNo checks are being made on the validity of the packages in config.\n\nShall I do it?" \
                  "install_apps"
                  ;;
      repo_rst)   _show_confirmation_dialog_for_tasks \
                  "Remove External Repositories" \
                  "I can remove External Repositories added and PPAs in the ppa. Apps installed via ppa will be reverted to original versions/uninstalled.\n\nShall I do it for you?" \
                  "disable_external_repos"
                  ;;
      ppa_rst)    _show_confirmation_dialog_for_tasks "Purge PPAs is ppa or mentioned in config."\
                  "PPAs listed in ppa.list or under YAML key config.ppa will be purged.\nThis will install ppa-purge on your system.\n\n Continue"
                  "purge_ppa"
                  ;;
      purge)      _show_confirmation_dialog_for_tasks \
                  "Purge Unwanted Packages" \
                  "Shall I Purge Unwanted packages mentioned in purge?" \
                  "purge_not_required"
                  ;;
      all)        _show_confirmation_dialog_for_tasks \
                  "All In One" "This task will do the following.\nUpdate Repositories\nUpgrade Packages\nAdd Repositories and PPAs\nInstall apps from List\nPurge Unwanted Packages\n\nContinue?" \
                  "all_in_one"
                  ;;
      debs)       _show_confirmation_dialog_for_tasks \
                  "Download & Install DEB files" "DEB Files in the config will be Download and installed. Proceed with the task?" \
                  "install_debs"
                  ;;
      pip2)       _show_confirmation_dialog_for_tasks \
                  "Install Python2 packages" "Python packaes for Python 2 mentioned in config will be installed via pip. If necessary python-pip package will be installed from apt. \n\nProceed?" \
                  "install_pip_packages_2"
                  ;;
      pip3)       _show_confirmation_dialog_for_tasks \
                  "Install Python3 packages" \
                  "Python packaes for Python 3 mentioned in the config will be installed via pip. If necessary python3-pip package will be installed from apt.\n\nProceed?" \
                  "install_pip_packages_3"
                  ;;
      bin)        _show_confirmation_dialog_for_tasks \
                  "Install Static Binaries" \
                  "Download & Install binaries listed in config.install.binaries?" \
                  "install_binaries"
                  ;;
      snaps)     _show_confirmation_dialog_for_tasks \
                  "Install Snap Packages" \
                  "Download & Install binaries listed in config.install.snaps?" \
                  "install_snaps"
                  ;;
      log)        _log_debug "Delete log selected"
                  delete_log_file;
                  ;;
    esac
    else
      _log_debug "Whiptail Exit code : $whiptail_exitstatus"
      _log_debug "Exiting because user selected Quit or Whiptail has non zero exit code."
    fi
}


function _ci_cloud_and_container_checks()
{

  if [ "$bool_skip_env_checks" == "true" ]; then
    _log_debug "Skipping Run environment checks"
  else
    _log_and_show "${_running} Env checks..."
    # Check if running in CI & Containers
    # VMs, GCP, AWS, Docker.
    #================================ CI =============================================
    if [ "$TRAVIS" == "true" ]; then
      _log_and_show "${_ci} Running in Travis CI"
    elif [ "$APPVEYOR" == "true" ]; then
      _log_and_show "${_ci} Running in Appveyor CI"
    elif [ "$TF_BUILD" == "True" ]; then
      _log_and_show "${_ci} Probably running on Azure Pipelines"
    elif [ "$GITHUB_ACTIONS" == "true" ]; then
      _log_and_show "${_ci} I'm running on GitHub Actions"
    fi

    # CI checks
    if [ "$CI" == "true" ]; then
      _log_and_show "${_ci} Probably running in a CI"
    fi

    # Internal checks
    if [ "$AE_INTERNAL_CI_MODE" == "true" ]; then
      _log_dev "Enforcing CI MODE"
      _log_dev "This is to be used only while testing the script."
      _log_dev "This will ignore --simulate flag in some cases!!"
    fi

    if [ "$(uname -r | cut -f3 -d '-')" == "Microsoft" ]; then
      _log_warn "${_warn} Running on Windows Subsystem for Linux.(1)"
    fi
    #============================ Docker =============================================
    if grep docker /proc/1/cgroup -qa; then
      _log_and_show "${_info} Running in Docker."
      #AE_RUNNING_IN_DOCKER=1
    else
      _log_debug "Probably not running in docker"
    fi
    #------------------------------- EC2, GCP, DO ------------------------------------
    # This first, simple check will work for many older instance types.
    if [ -f /sys/hypervisor/uuid ] && [ "$(head -c 3 /sys/hypervisor/uuid)" == "ec2" ]; then
      _log_and_show "${_info} Running on EC2"

    # This check will work on newer m5/c5 instances, but only if you have root!
    # If the file exists AND is readable by us, we can rely on it.
    elif [ -r /sys/devices/virtual/dmi/id/product_uuid ] && [ "$(head -c 3 /sys/devices/virtual/dmi/id/product_uuid)" == "EC2" ]; then
      _log_and_show "${_info} Running on EC2"

    # Fallback check of http://169.254.169.254/. If we wanted to be REALLY
    # authoritative, we could follow Amazon's suggestions for cryptographically
    # verifying their signature, see here:
    #    https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html
    # but this is almost certainly overkill for this purpose (and the above
    # checks of "EC2" prefixes have a higher false positive potential, anyway).
    elif wget -O- -q --timeout=1 --tries=1 http://169.254.169.254/latest/dynamic/instance-identity/document | grep -q availabilityZone; then
      _log_and_show "${_info} Running on EC2"

    #------------------------------- GCP ---------------------------------------------
    elif wget -q -O- --timeout=1 --tries=1 -nc --header="Metadata-Flavor: Google" http://169.254.169.254/computeMetadata/v1/instance/virtual-clock/drift-token > /dev/null; then
      _log_and_show "${_info} Running on Google Compute"

    elif wget -q -O- --timeout=1 --tries=1 -nc  http://169.254.169.254/metadata/v1/id; then
      _log_and_show "${_info} Running on Digital Ocean Droplet"

    elif AZURE_REGION="$(wget -q -O- --timeout=1 --tries=1 --header "Metadata:true" "${AZURE_METADATA_URL}")"; then
      _log_and_show "${_info} Running on AZURE ${AZURE_REGION}"

    else
      _log_debug "Probably not running on AWS, GCP, Azure or Digital Ocean."
    fi

  fi

}

function display_version()
{
  printf "%-15s : %s\n" "Version Number" "${REL_NUM}"
  printf "%-15s : %s\n" "Version Name" "${REL_NAME}"
  printf "%-15s : %s\n" "Executable" "${SCRIPT}"
}


function display_usage()
{
#Prints out help menu
cat <<EOF
${GREEN}
A Post Installation Script for Ubuntu/Debian/Linux Mint${NC}
Usage: ${GREEN} [sudo] ./${SCRIPT} ${YELLOW}  [options]${NC}
${YELLOW}
Non-Action options (can be run as non-root user)
-------------------------------------------------${NC}
[-v --version]     Display version info
[-h --help]        Display this help message
${YELLOW}
Configuration Options
-------------------------------------------------${NC}
[-c | --config-file]   Local yaml config file
[-R | --remote-yaml]   Use config yaml hosted somewhere else
${BLUE}
The following options are "action" options and
will make changes to your system depending on tasks chosen.
-------------------------------------------------${NC}
[-d | --purge]         Enable Purging packages
[-f | --fix]           Fix codenames for new releases
[-p | --pre-release]   Same as --fix but for beta/alpha releases
[--fix-mode-lts]       Similar to --fix but fallback to last LTS
                       Should be used with --fix
[-k | --keep-debs]     Do not invoke apt-clean & do not delete
                       downloaded deb packages
[-l | --delete-log]    Delete logfile (./log/after-effects.log)
[-s | --simulate]      Try not make changes to system and use --dry-run
                       Please read the documentation, to know its limits
                       as everything cannot be simulated.
${YELLOW}
Other Options
-------------------------------------------------${NC}
[-E | --skip-env-checks]     Skip some env checks
[-V | --skip-version-check]  Skip checking for latest version
[-H --hide-config]           Hide configuration table
[-A --autopilot]             Enables AUTOPILOT mode(No Prompts)
${GREEN}
Links & License
-------------------------------------------------${NC}
GitHub          : ${BLUE}https://git.io/Jv08V${NC}
Documentation   : ${BLUE}https://ae.prasadt.com${NC}
* This script is licensed under GPLv3.
* Show your support by starring the repo on GitHub
-------------------------------------------------
EOF
}

function _process_non_root_options()
{
  # Process command line arguments which does not require root.
  if [[  $# -eq 0 ]]; then
    set_red
    printf "Error! No arguments specified! See Usage Below\n"
    set_default
    display_usage
    exit 1
  elif [[  $# -eq 1 ]]; then
    while [ "${1}" != "" ]; do
      case ${1} in
        -v | --version)   display_version;
                          exit 0;
                          ;;
        -G | --verify)    verify_gpg_signature;
                          exit 0;
                          ;;
      -l | --delete-log)  delete_log_file;
                          ;;
      -L | --lists)       set_red;
                          printf "${_error} List mode is no longer supported.";
                          set_default;
                          exit 53;;
        -h | --help)      display_usage;
                          exit 0;
                          ;;
        *)                printf "${_error} This does not appear to be a valid option\n";
                          printf "${_error} Non action options take more than one argument!\n";
                          exit 1;
                          ;;
      esac
      shift
    done
  fi
}


function main()
{
  _init_printf_variables

  # Display Version Info and Verify signature options
  _process_non_root_options "$@"

  _line_fill;
  printf "${_checking} Permissions...\n"

  if [[ $AE_INTERNAL_NO_EXECUTE -eq 1 ]]; then
    # Actual logging starts
    _init_logging
    _log_dev "Running in no Execute mode"
  elif [[ $EUID -ne 0 ]]; then
    set_red;
    printf "${_whoops} Insufficient privileges!!\n"
    printf "${_error} This script must be run as root.\n"
    printf "${_error} Please use sudo ${dir}/$SCRIPT to run this as root.\n"
    set_default;
    _line_fill;
    exit 2;
  else
    # We were not running in NX mode, and we are root.
    _init_logging
    _log_success "${_success} OK! running as root."
  fi

  # Init vars
  _init_script_variables;

  # Process command line arguments.
  while [ "${1}" != "" ]; do
    case ${1} in
      -s | --simulate)        readonly simulate_apt_install="true";
                              _log_warn "${_simulate} is set to true";
                             ;;
      -f | --fix)             bool_fix_repo_not_available_for_latest="true";
                              _log_warn "${_fix_repo} is set to true.";
                              ;;
      --fix-mode-lts)         bool_fix_repo_lts="true";
                              _log_warn "${_fix_repo} Fix mode is set to LTS: $codename_lts_fallback.";
                              ;;
      -p | --pre-release)     bool_fix_repo_not_available_for_upcoming_release="true";
                              set_magenta;
                              _log_and_show "${_fix_repo} for upcoming release is set to true.";
                              set_default;
                              ;;
      -d | --purge)           bool_purge_not_required_pkgs="true";
                              _log_and_show "${_purge} Purge packages is set to true."
                              _log_warn "${_warn} No checks are being made on the Packages in the list."
                              _log_warn "${_warn} Use carefully!. Purging system packages is stupid idea!"
                              ;;
      -y | --yes)             _log_warn "${_warn} -y | --yes is no longer availanle, Use Autopilot instead";
                              ;;
      -k | --keep-debs)       bool_preserve_debs="true";
                              _log_and_show "${_info} Will keep downloaded DEB packages."
                              ;;
  -V | --skip-version-check)  bool_check_version="false";
                              ;;
      --version-file)         shift;
                              readonly custom_version_file="${1}";
                              readonly bool_custom_version_file="true"
                              _log_and_show "${_info} Using custom version yml file"
                              ;;
      -R | --remote-yaml)     _log_and_show "${_info} Using Remote YAML";
                              readonly bool_remote_yaml="true";
                              shift;
                              readonly url_remote_yaml="${1}";
                              ;;
    -c | --config-file)       shift;
                              readonly custom_config_file="${1}";
                              readonly bool_custom_config_file="true";
                              _log_and_show "${_info} Using local config file"
                              ;;
    -H | --hide-config)       readonly bool_hide_config="true";
                              _log_and_show "${_info} YAML config will not be displayed."
                              ;;
      --internal-ci-mode)     readonly AE_INTERNAL_CI_MODE="true";;
      -A | --autopilot)       readonly AE_AUTOPILOT="true";;
      --use-uf-mirror)        _log_and_show "Will use Uni-Freiburg mirror(s) if available";
                              readonly bool_use_uni_freiburg_mirror="true";
                              ;;
      -E | --skip-env-checks) readonly bool_skip_env_checks="true";;
      # The following arguments should always be used as the only arguments.
      -l | --delete-logfile)  _log_and_exit "${_error} -l or --delete-logfile should be the only argument." "23";;
      -v | --version)         _log_and_exit "${_error} -v or --version should be the only argument." "23";;
      -G | --verify)          _log_and_exit "${_error} --verify should be the only argument." "23";;
       -h | --help)           _log_and_exit "${_error} -h or --help should be the only argument." "23";;
       *)                     _log_and_exit "${_error} Invalid option: $1" "22";;
    esac
    shift
  done


  # Initialize variables and checks
  local after_effects_core_dependencies=(wget whiptail ping ps grep cut tr awk)
  _check_dependencies "${after_effects_core_dependencies[@]}"

  _init_print_basic_info;

  # I don't like when someone else is occupying my room
  # Test if any apt-get ops are running
  _test_conflicting_apps;

  # Did I tell you that I need to call My friends over internet?
  _test_internet_connection;

  # Checks CI & Containers If running on EC2/GCP/Azure/DO
  _ci_cloud_and_container_checks;

  # Take care of Mint and other distros
  _fix_ubuntu_derivatives;


  if [ "$bool_custom_config_file" == "true" ] && [ "$bool_remote_yaml" == "true" ]; then
    _log_and_exit "${_error} Cannot use local config (-C) with remote YAML (-R) Use one of them." "25"
  fi

  if [ "$bool_custom_config_file" == "true" ] && [ ! -f "$custom_config_file" ]; then
    _log_and_exit "${_error} Config file you have specified is not found or not accessible" "36"
  fi

  if [ "$bool_custom_version_file" == "true" ] && [ ! -f "$custom_version_file" ]; then
    _log_and_exit "${_error} Custom version info file you have specified is not found or not accessible" "36"
  fi

  # Handle Remote YAML

  if [ "$bool_remote_yaml" == "true" ]; then
    _log_debug "Will use config ${api_config_url}"
  elif [ "$bool_custom_config_file" == "true" ]; then
    _log_debug "Config file specified will be used."
  fi

  # Version, Config and GPG signature URLS
  _log_debug "Version Info URL is: ${api_version_url}"

  # Get Remote Config File/s, check version & configure
  _version_checks;

  _set_yaml_config;

  if [[ ! -t 1 ]] && [[ $AE_AUTOPILOT != "true" ]]; then
    _log_error "Terminal is not interactive, yet you have not specified --autopilot flag!"
    _log_and_exit "Non Interactive Terminal requires --autopilot" "54"
  fi

  if [[ $AE_INTERNAL_NO_EXECUTE -eq 1 ]]; then
    _log_dev "Will not Execute any Tasks!"
    _script_exit_log;
    exit 255
  fi

  # Autopilot
  if [[ ${AE_AUTOPILOT} == "true" ]]; then
    bool_say_yes_to_all="true"
    _log_notice "${_autopilot} Active"
    sleep 3;
    #_log_and_exit "Because I can" "255"
    _autopilot_check_task_flag_and_run "$ae_task_update" "update_repos"
    _autopilot_check_task_flag_and_run "$ae_task_upgrade" "upgrade_apps"
    _autopilot_check_task_flag_and_run "$ae_task_repo" "add_repositories"
    _autopilot_check_task_flag_and_run "$ae_task_ppa" "add_ppas"
    _autopilot_check_task_flag_and_run "$ae_task_apt" "install_apps"
    _autopilot_check_task_flag_and_run "$ae_task_debs" "install_debs"
    _autopilot_check_task_flag_and_run "$ae_task_pip2" "install_pip_packages_2"
    _autopilot_check_task_flag_and_run "$ae_task_pip3" "install_pip_packages_3"
    _autopilot_check_task_flag_and_run "$ae_task_purge" "purge_not_required"
    _autopilot_check_task_flag_and_run "$ae_task_bin" "install_binaries"
    _autopilot_check_task_flag_and_run "$ae_task_snaps" "install_snaps"
  else
  _process_menu;
  #_log_and_show "DEBUG: Options Processed"
  fi

  _script_exit_log;
}

#Run Main
main "$@"
